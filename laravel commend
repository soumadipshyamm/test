class BackupAndMigrate extends Command
{
    protected $signature = 'migrate';
    protected $description = 'Backup SQLite database, create a new one, and run migrations';

    public function handle()
    {
        // Step 1: Create a SQLite database
        $databasePath = database_path('database.sqlite');
        if (file_exists($databasePath)) {
            touch($databasePath);
            $this->info('SQLite database created.');
        }

        // Step 2: Backup existing data
        $backupPath = storage_path('backups');
        if (!is_dir($backupPath)) {
            mkdir($backupPath, 0755, true);
        }

        $backupFile = $backupPath . '/backup_' . date('Y_m_d_H_i_s') . '.sql';
        $tables = DB::select('SHOW TABLES');

        foreach ($tables as $table) {
            $tableName = $table->{"Tables_in_" . env('DB_DATABASE')}; // Adjust as per your DB setup
            $data = DB::table($tableName)->get();
            $sql = "INSERT INTO $tableName VALUES ";
            foreach ($data as $row) {
                $sql .= "(" . implode(',', array_map(fn($value) => "'" . addslashes($value) . "'", (array)$row)) . "),";
            }
            $sql = rtrim($sql, ',') . ";";
            file_put_contents($backupFile, $sql, FILE_APPEND);
        }
        $this->info('Backup created at: ' . $backupFile);
        // Step 3: Run migrations
        $this->call('migrate');
        $this->info('Migrations executed successfully.');
    }
}


hbhhhhhhhhhhhhhhhhhhhhhhjnnnnjnjnnnnnnnnnbbnnnnnnnjj
<?php

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\File;

class BackupAndMigrate extends Command
{
    protected $signature = 'backup-and-migrate';
    protected $description = 'Backup SQLite database, create a new one, and run migrations';

    public function handle()
    {
        // Step 1: Create a SQLite database if it doesn't exist
        $databasePath = database_path('database.sqlite');
        if (!file_exists($databasePath)) {
            File::put($databasePath, '');
            $this->info('SQLite database created.');
        }

        // Step 2: Backup existing data
        $backupPath = storage_path('backups');
        if (!is_dir($backupPath)) {
            mkdir($backupPath, 0755, true);
        }

        $backupFile = $backupPath . '/backup_' . date('Y_m_d_H_i_s') . '.sql';

        // Get list of all tables in the SQLite database
        $tables = DB::select('SELECT name FROM sqlite_master WHERE type="table"');

        foreach ($tables as $table) {
            $tableName = $table->name;

            // Skip internal SQLite tables
            if ($tableName == 'sqlite_sequence' || $tableName == 'migrations') {
                continue;
            }

            $data = DB::table($tableName)->get();
            $sql = "INSERT INTO $tableName VALUES ";

            foreach ($data as $row) {
                $sql .= "(" . implode(',', array_map(fn($value) => $this->formatValue($value), (array)$row)) . "),";
            }

            $sql = rtrim($sql, ',') . ";";
            file_put_contents($backupFile, $sql, FILE_APPEND);
        }

        $this->info('Backup created at: ' . $backupFile);

        // Step 3: Run migrations
        $this->call('migrate');
        $this->info('Migrations executed successfully.');
    }

    // Helper function to handle SQL formatting
    private function formatValue($value)
    {
        if (is_null($value)) {
            return 'NULL';
        }
        if (is_numeric($value)) {
            return $value;
        }
        return "'" . addslashes($value) . "'";
    }
}
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

class BackupAndMigrate extends Command
{
    protected $signature = 'backup-and-migrate';
    protected $description = 'Backup SQLite database, create a new one, and run migrations';

    public function handle()
    {
        // Step 1: Create SQLite database
        $databasePath = database_path('database.sqlite');
        if (!file_exists($databasePath)) {
            touch($databasePath);
            $this->info('SQLite database created.');
        } else {
            $this->info('SQLite database already exists.');
        }

        // Step 2: Backup existing data
        $backupPath = storage_path('backups');
        if (!is_dir($backupPath)) {
            mkdir($backupPath, 0755, true);
        }

        $backupFile = $backupPath . '/backup_' . date('Y_m_d_H_i_s') . '.sql';

        try {
            // Fetch all tables in the database
            $tables = DB::select('SELECT name FROM sqlite_master WHERE type = "table" AND name NOT LIKE "sqlite_%"');
            
            foreach ($tables as $table) {
                $tableName = $table->name;

                // Skip migrations table to avoid unnecessary data restoration
                if ($tableName === 'migrations') {
                    continue;
                }

                $data = DB::table($tableName)->get();
                $sql = "INSERT INTO $tableName VALUES ";

                foreach ($data as $row) {
                    $sql .= "(" . implode(',', array_map(fn($value) => $this->quoteValue($value), (array)$row)) . "),";
                }

                $sql = rtrim($sql, ',') . ";\n";
                file_put_contents($backupFile, $sql, FILE_APPEND);
            }

            $this->info('Backup created at: ' . $backupFile);

        } catch (\Exception $e) {
            $this->error('Error creating backup: ' . $e->getMessage());
            return;
        }

        // Step 3: Run migrations
        $this->call('migrate');
        $this->info('Migrations executed successfully.');
    }

    /**
     * Helper function to quote values for SQL insertion.
     *
     * @param mixed $value
     * @return string
     */
    private function quoteValue($value)
    {
        if (is_null($value)) {
            return 'NULL';
        }
        return "'" . addslashes($value) . "'";
    }
}

'connections' => [
    'sqlite' => [
        'driver' => 'sqlite',
        'url' => env('DATABASE_URL'),
        'database' => database_path('database.sqlite'),
        'prefix' => '',
        'foreign_key_constraints' => env('DB_FOREIGN_KEYS', true),
    ],
],


<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;

class BackupAndMigrate extends Command
{
    protected $signature = 'backup-and-migrate';
    protected $description = 'Backup SQLite database, create a new one, and run migrations';

    public function handle()
    {
        // Step 1: Create a SQLite database
        $databasePath = database_path('database.sqlite');
        if (!file_exists($databasePath)) {
            touch($databasePath);
            $this->info('SQLite database created at: ' . $databasePath);
        } else {
            $this->info('SQLite database already exists at: ' . $databasePath);
        }

        // Step 2: Backup existing data
        $this->info('Starting database backup...');
        $backupPath = storage_path('backups');
        if (!is_dir($backupPath)) {
            mkdir($backupPath, 0755, true);
        }

        $backupFile = $backupPath . '/backup_' . date('Y_m_d_H_i_s') . '.sql';

        try {
            DB::connection()->getPdo(); // Check if DB is accessible
            $tables = DB::select('SHOW TABLES'); // MySQL only; adapt for other DBs

            $databaseName = env('DB_DATABASE');
            $sqlDump = '';

            foreach ($tables as $table) {
                $tableName = $table->{"Tables_in_$databaseName"};
                $data = DB::table($tableName)->get();

                $sqlDump .= "TRUNCATE TABLE $tableName;\n";

                foreach ($data as $row) {
                    $values = implode(',', array_map(fn($value) => "'" . addslashes($value) . "'", (array)$row));
                    $sqlDump .= "INSERT INTO $tableName VALUES ($values);\n";
                }
            }

            file_put_contents($backupFile, $sqlDump);
            $this->info('Backup created successfully at: ' . $backupFile);
        } catch (\Exception $e) {
            $this->error('Failed to backup the database: ' . $e->getMessage());
            return;
        }

        // Step 3: Run migrations
        $this->info('Running migrations...');
        $this->call('migrate', ['--force' => true]);
        $this->info('Migrations executed successfully.');
    }
}

<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;
use Symfony\Component\Process\Process;

class BackupDatabase extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'backup:database {filename?}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Backup the database as a file';

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        // Get the database configuration
        $dbHost = env('DB_HOST', '127.0.0.1');
        $dbPort = env('DB_PORT', '3306');
        $dbName = env('DB_DATABASE', 'laravel');
        $dbUser = env('DB_USERNAME', 'root');
        $dbPass = env('DB_PASSWORD', '');

        // Generate the backup filename
        $filename = $this->argument('filename') ?? 'backup_' . date('Y_m_d_His') . '.sql';
        $backupPath = storage_path("app/{$filename}");

        // Prepare the command
        $command = sprintf(
            'mysqldump -h%s -P%s -u%s -p%s %s > %s',
            escapeshellarg($dbHost),
            escapeshellarg($dbPort),
            escapeshellarg($dbUser),
            escapeshellarg($dbPass),
            escapeshellarg($dbName),
            escapeshellarg($backupPath)
        );

        // Execute the command
        $process = Process::fromShellCommandline($command);
        $process->run();

        if ($process->isSuccessful()) {
            $this->info("Database backup completed successfully: {$filename}");
        } else {
            $this->error('Failed to back up the database.');
            $this->error($process->getErrorOutput());
        }

        return 0;
    }
}


<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class BackupDatabase extends Command
{
    // Command signature
    protected $signature = 'db:backup 
                            {--path= : The file path where the backup will be saved} 
                            {--log= : Log file path for the backup process}';

    // Command description
    protected $description = 'Backup the database to a file and log the process';

    public function __construct()
    {
        parent::__construct();
    }

    public function handle()
    {
        $this->info('Starting database backup...');

        // Get database configuration from the .env file
        $dbHost = env('DB_HOST');
        $dbPort = env('DB_PORT', 3306);
        $dbName = env('DB_DATABASE');
        $dbUser = env('DB_USERNAME');
        $dbPass = env('DB_PASSWORD');

        // Determine file path for the backup
        $filePath = $this->option('path') ?? storage_path('backups/' . $dbName . '_' . date('Y-m-d_H-i-s') . '.sql');
        $logPath = $this->option('log') ?? storage_path('logs/db_backup.log');

        // Ensure the backup directory exists
        $backupDirectory = dirname($filePath);
        if (!is_dir($backupDirectory)) {
            mkdir($backupDirectory, 0755, true);
        }

        // Set up logging
        $logger = Log::build([
            'driver' => 'single',
            'path' => $logPath,
        ]);

        // Create the mysqldump command
        $dumpCommand = sprintf(
            'mysqldump --host=%s --port=%d --user=%s --password=%s %s > %s',
            escapeshellarg($dbHost),
            escapeshellarg($dbPort),
            escapeshellarg($dbUser),
            escapeshellarg($dbPass),
            escapeshellarg($dbName),
            escapeshellarg($filePath)
        );

        // Execute the command
        $this->info('Executing backup command...');
        $output = null;
        $resultCode = null;
        exec($dumpCommand, $output, $resultCode);

        // Log and handle the result
        if ($resultCode === 0) {
            $message = "Backup successful! File saved to: {$filePath}";
            $this->info($message);
            $logger->info($message);
        } else {
            $error = "Backup failed with error code {$resultCode}. Check the mysqldump command and permissions.";
            $this->error($error);
            $logger->error($error);
        }
    }
}

