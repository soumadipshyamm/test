




******************
let cancelledBookingTable = $('#cancelledBookingTable').DataTable({
    responsive: true,
    searching: false,
    lengthChange: true,
    "language": {
        lengthMenu: "Counts per page_MENU_",
        searchPlaceholder: "Search by name"
    },
    autoWidth: false,
    processing: true,
    serverSide: true,
    ajax: {
        url: baseUrl + 'ajax/getCancelledBookings',
        dataType: "json",
        type: "get",
        data: function (d) {
            return $.extend({}, d, {
                'daterange': $(".daterange").val(),
            });
        },
    },
    columns: cancelledBookingDataColumn,
    dom: '<".d-flex"<".col-10" l><".col-2 text-right" Bf>>t<".d-flex"<".col-6" i><".col-6 text-right"p>>',
    buttons: [
        {
            extend: 'excelHtml5',
            text: 'Export Excel',
            action: function (e, dt, button, config) {
                $.ajax({
                    url: baseUrl + 'ajax/exportAllCancelledBookings', // Separate API to get all data
                    type: 'get',
                    success: function (data) {
                        let blob = new Blob([data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        let link = document.createElement('a');
                        link.href = window.URL.createObjectURL(blob);
                        link.download = 'Cancelled_Bookings.xlsx';
                        link.click();
                    }
                });
            }
        },
        {
            extend: 'pdfHtml5',
            text: 'Export PDF'
        },
        {
            extend: 'print',
            text: 'Print'
        }
    ],
    "ordering": true,
    "scrollX": "400px", // Set the height for the scrollable area
    "scrollCollapse": true,
    "fnDrawCallback": function (oSettings) {
        let pagination = $(oSettings.nTableWrapper).find('.dataTables_paginate,.dataTables_info,.dataTables_length');
        oSettings._iDisplayLength > oSettings.fnRecordsDisplay() ? pagination.hide() : pagination.show();
    },
    "createdRow": function (row, data, dataIndex) {
        $(row).addClass('manage-enable');
        if (data.is_active) {
            $(row).addClass('block-disable');
        }
    }
});


****************************

let cancelledBookingTable = $('#cancelledBookingTable').DataTable({
    responsive: true,
    searching: false,
    lengthChange: true,
    "language": {
        lengthMenu: "Counts per page _MENU_",
        searchPlaceholder: "Search by name"
    },
    autoWidth: false,
    processing: true,
    serverSide: true,
    ajax: {
        url: baseUrl + 'ajax/getCancelledBookings',
        dataType: "json",
        type: "get",
        data: function (d) {
            return $.extend({}, d, {
                'daterange': $(".daterange").val(),
            });
        },
    },
    columns: cancelledBookingDataColumn,
    dom: '<".d-flex"<".col-10" l><".col-2 text-right" Bf>>t<".d-flex"<".col-6" i><".col-6 text-right"p>>',
    buttons: [
        {
            extend: 'excelHtml5',
            text: 'Export Excel',
            exportOptions: {
                modifier: {
                    page: 'all' // Export all data, not just the current page
                }
            },
            action: function (e, dt, button, config) {
                // To fetch all data for export
                $.ajax({
                    url: baseUrl + 'ajax/getCancelledBookings',
                    data: dt.ajax.params(), // Send the current filter data
                    success: function (json) {
                        let exportData = json.data;
                        let newDataTable = $.extend(true, [], dt.buttons.exportData());
                        newDataTable.body = exportData; // Assign full data to be exported
                        $.fn.dataTable.ext.buttons.excelHtml5.action.call(this, e, dt, button, $.extend({}, config, {
                            exportOptions: {
                                columns: ':visible',
                                rows: ':visible'
                            },
                            data: newDataTable
                        }));
                    }
                });
            }
        },
        {
            extend: 'pdfHtml5',
            text: 'Export PDF',
            exportOptions: {
                modifier: {
                    page: 'all' // Export all data, not just the current page
                }
            },
            action: function (e, dt, button, config) {
                // Fetch all data for export
                $.ajax({
                    url: baseUrl + 'ajax/getCancelledBookings',
                    data: dt.ajax.params(),
                    success: function (json) {
                        let exportData = json.data;
                        let newDataTable = $.extend(true, [], dt.buttons.exportData());
                        newDataTable.body = exportData;
                        $.fn.dataTable.ext.buttons.pdfHtml5.action.call(this, e, dt, button, $.extend({}, config, {
                            data: newDataTable
                        }));
                    }
                });
            }
        },
        {
            extend: 'print',
            text: 'Print'
        }
    ],
    "ordering": true,
    "scrollX": "400px",
    "scrollCollapse": true,
    "fnDrawCallback": function (oSettings) {
        let pagination = $(oSettings.nTableWrapper).find('.dataTables_paginate,.dataTables_info,.dataTables_length');
        oSettings._iDisplayLength > oSettings.fnRecordsDisplay() ? pagination.hide() : pagination.show();
    },
    "createdRow": function (row, data, dataIndex) {
        $(row).addClass('manage-enable');
        if (data.is_active) {
            $(row).addClass('block-disable');
        }
    }
});

***********************************************
let cancelledBookingTable = $('#cancelledBookingTable').DataTable({
    responsive: true,
    searching: false,
    lengthChange: true,
    "language": {
        lengthMenu: "Counts per page_MENU_",
        searchPlaceholder: "Search by name"
    },
    autoWidth: false,
    processing: true,
    serverSide: true,
    ajax: {
        url: baseUrl + 'ajax/getCancelledBookings',
        dataType: "json",
        type: "get",
        data: function (d) {
            return $.extend({}, d, {
                'daterange': $(".daterange").val(),
            });
        },
    },
    columns: cancelledBookingDataColumn,
    dom: '<".d-flex"<".col-10" l><".col-2 text-right" Bf>>t<".d-flex"<".col-6" i><".col-6 text-right"p>>',
    buttons: [
        {
            extend: 'excelHtml5',
            text: 'Export Excel',
            exportOptions: {
                modifier: {
                    page: 'all' // Export all data, not just the current page
                }
            }
        },
        {
            extend: 'pdfHtml5',
            text: 'Export PDF'
        },
        {
            extend: 'print',
            text: 'Print'
        }
    ],
    "ordering": true,
    "scrollX": "400px", // Set the height for the scrollable area
    "scrollCollapse": true,
    "fnDrawCallback": function (oSettings) {
        let pagination = $(oSettings.nTableWrapper).find('.dataTables_paginate,.dataTables_info,.dataTables_length');
        oSettings._iDisplayLength > oSettings.fnRecordsDisplay() ? pagination.hide() : pagination.show();
    },
    "createdRow": function (row, data, dataIndex) {
        $(row).addClass('manage-enable');
        if (data.is_active) {
            $(row).addClass('block-disable');
        }
    }
});

*********************************************************************************************
let vehiclesReportsTable = $('#vehiclesReportsTable').DataTable({
    responsive: true,
    searching: false,
    lengthChange: true,
    "language": {
        lengthMenu: "Counts per page_MENU_",
        searchPlaceholder: "Search by name"
    },
    autoWidth: false,
    processing: true,
    serverSide: true,
    ajax: {
        url: baseUrl + 'ajax/getVehiclesReports',
        dataType: "json",
        type: "get",
        data: function (d) {
            return $.extend({}, d, {
                "plate_no": $(".plate_no").val() ?? '',
                "name": $(".name").val() ?? ''
            });
        },

    },
    columns: vehiclesReports,
    dom: '<".d-flex"<".col-10" l><".col-2 text-right" Bf>>t<".d-flex"<".col-6" i><".col-6 text-right"p>>',
    buttons: [
        {
            extend: 'excelHtml5',
            text: 'Export Excel',
            exportOptions: {
                columns: ':visible', // Export only visible columns
                modifier: {
                    search: 'applied', // Apply current search filter
                    order: 'applied',  // Apply current order
                    page: 'all'        // Export all pages
                }
            }
        },
        {
            extend: 'print',
            text: 'Print',
            exportOptions: {
                columns: ':visible'
            }
        }
    ],
    "ordering": true,
    "fnDrawCallback": function (oSettings) {
        let pagination = $(oSettings.nTableWrapper).find('.dataTables_paginate,.dataTables_info,.dataTables_length');
        oSettings._iDisplayLength > oSettings.fnRecordsDisplay() ? pagination.hide() : pagination.show();
    },
    "createdRow": function (row, data, dataIndex) {
        $(row).addClass('manage-enable');
        if (data.is_active) {
            $(row).addClass('block-disable');
        }
    }
});
*********************************************************************************************
protected static function generateUniqueNumber($length)
{
    // Get the current year in 'yy' format (e.g., 24 for 2024)
    $year = date('y');
    
    // Initialize the employee ID
    $number = str_pad(mt_rand(1, pow(10, $length) - 1), $length, '0', STR_PAD_LEFT);

    // Full employee ID in format 'EMP-2400001'
    $employeeId = 'EMP-' . $year . $number;

    // Log for debugging (optional)
    info("Generated Employee ID: $employeeId");

    // Check if the generated number is unique in the database
    while (static::where('employee_id', $employeeId)->exists()) {
        // If not unique, regenerate the employee ID
        $number = str_pad(mt_rand(1, pow(10, $length) - 1), $length, '0', STR_PAD_LEFT);
        $employeeId = 'EMP-' . $year . $number;
        
        // Log for debugging (optional)
        info("Regenerated Employee ID: $employeeId");
    }

    // Return the unique employee ID
    return $employeeId;
}

**************n********************************
            $model->employee_id  = static::generateUniqueNumber(6);

 protected static function generateUniqueNumber($length)
    {
        $year = date('y');
        info($year);
        $number = str_pad(mt_rand(1, pow(10, $length) - 1), $length, '0', STR_PAD_LEFT);
        info($number);
        // Check if the generated number is unique in the database
        while (static::where('employee_id', $number)->exists()) {
            $number = 'EMP-' . $year . str_pad(mt_rand(1, pow(10, $length) - 1), $length, '0', STR_PAD_LEFT);
            info($number);
        }
    }
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
***********************************************************************************************************n********************************
public function bookinglist(Request $request)
{
    // Fetch bookings filtered by conditions
    $filtered = Booking::whereNull('driver_id')
        ->where('is_accepted', 1)
        ->whereIn('status', [0, 1])
        ->where('created_at', '>=', Carbon::now()->subMinutes(2))
        ->orderByDesc('id')
        ->get();

    // Check if any booking is found
    if ($filtered->isNotEmpty()) {
        return $this->responseJson(true, 200, 'Booking Fetched Successfully', BookingResource::collection($filtered));
    }

    return $this->responseJson(false, 200, 'No Data Found !!', []);
}


*******************************************************************************************************************************************
public function bookinglist(Request $request)
{
    $latitude = $request->input('latitude');
    $longitude = $request->input('longitude');
    $radius = $request->input('radius', 10); // Default 10km

    // Fetch bookings filtered by conditions
    $filtered = Booking::whereNull('driver_id')
        ->where('is_accepted', 1)
        ->whereIn('status', [0, 1])
        ->where('created_at', '>=', Carbon::now()->subMinutes(2))
        ->orderByDesc('id')
        ->get();

    if ($filtered->isNotEmpty()) {
        // Fetch nearby drivers within the radius and with approved documents
        $nearbyDrivers = User::role('driver') // Check for drivers using the role check
            ->where('is_online', true) // Only fetch drivers who are online
            ->whereHas('documents', function($query) {
                // Check for specific documents and ensure they are approved
                $query->whereIn('document_type', [
                    'vehicle_documents', 
                    'noc_document', 
                    'rc_document_front', 
                    'rc_document_back', 
                    'aadhar_document_front', 
                    'aadhar_document_back', 
                    'licence_document_front', 
                    'licence_document_back', 
                    'pan_card'
                ])->where('status', 'approved');
            })
            ->selectRaw("id, name, latitude, longitude, ( 6371 * acos( cos( radians(?) ) * cos( radians( latitude ) ) * cos( radians( longitude ) - radians(?) ) + sin( radians(?) ) * sin( radians( latitude ) ) ) ) AS distance", [$latitude, $longitude, $latitude])
            ->having("distance", "<", $radius) // Check within the given radius
            ->orderBy("distance")
            ->get();

        if ($nearbyDrivers->isNotEmpty()) {
            return $this->responseJson(true, 200, 'Booking and Nearby Drivers Fetched Successfully', [
                'bookings' => BookingResource::collection($filtered),
                'nearby_drivers' => $nearbyDrivers
            ]);
        } else {
            return $this->responseJson(false, 200, 'No Nearby Drivers Found !!', [
                'bookings' => BookingResource::collection($filtered),
                'nearby_drivers' => []
            ]);
        }
    }

    return $this->responseJson(false, 200, 'No Bookings Found !!', []);
}

*******************************************************************************************************************************************
public function tripReached(Request $request)
{
    // Validate request
    $validator = Validator::make($request->all(), [
        'uuid' => 'required|exists:bookings,uuid',
        'lat' => 'required|numeric',
        'long' => 'required|numeric',
        'status' => 'sometimes|in:3,4', // Assuming status 3 and 4 are relevant
    ]);

    if ($validator->fails()) {
        return $this->responseJson(false, 422, $validator->errors()->first(), "");
    }

    DB::beginTransaction();
    try {
        // Get the booking ID from UUID
        $id = uuidtoid($request->uuid, 'bookings');
        $booking = Booking::find($id);

        if (!$booking) {
            return $this->responseJson(false, 404, 'Booking not found', "");
        }

        // Update the booking status
        $status = $request->status ?? 3; // Default to 3 if status is not provided
        $booking->update(['status' => $status]);

        // Log the booking status update
        $this->logBookingStatus($booking, $request);

        // Update or create a record in the bookingDrivers table
        $booking->bookingDrivers()->updateOrCreate(
            ['booking_id' => $booking->id],
            ['user_id' => auth()->user()->id, 'status' => $status]
        );

        // Commit transaction
        DB::commit();

        // Send notification if FCM tokens are available
        if (!empty($booking->user?->device_token)) {
            $notificationData = (object)[
                'body' => 'Your Ride has been completed',
                'title' => 'Ride Completed'
            ];
            $this->sendNotification($notificationData, $booking->user->device_token);
        }

        // Return success response
        return $this->responseJson(true, 200, 'Ride Completed Successfully', new BookingResource($booking));

    } catch (\Throwable $th) {
        DB::rollBack();
        // Log the error for debugging purposes
        logger($th->getMessage() . ' on ' . $th->getFile() . ' in ' . $th->getLine());
        return $this->responseJson(false, 500, 'Something Went Wrong');
    }
}

private function logBookingStatus($booking, $request)
{
    // Create a log entry for the booking status
    BookingLog::create([
        'booking_id' => $booking->id,
        'user_id' => auth()->user()->id,
        'lat' => $request->lat,
        'long' => $request->long,
        'status' => $request->status,
        'comment' => "Your Ride has been Reached"
    ]);
}

private function updateWalletAndLogBooking($booking, $request)
{
    // Placeholder for the wallet update logic
    // Perform any wallet updates or additional logging here
}

*******************************************************************************************************************************************
public function acceptOrRejectBooking(Request $request)
{
    // Validate request inputs
    $validator = Validator::make($request->all(), [
        'uuid' => 'required|uuid|exists:bookings,uuid',
        'is_accepted' => 'required|in:2,3', // 2 for accepted, 3 for rejected
    ]);

    if ($validator->fails()) {
        return $this->responseJson(false, 422, $validator->errors()->first(), "");
    }

    // Get booking by UUID
    $id = uuidtoid($request->uuid, 'bookings');
    $booking = Booking::find($id);

    if (!$booking) {
        return $this->responseJson(false, 404, 'Booking not found', []);
    }

    // Check if booking is already accepted
    if ($booking->driver_id && $request->is_accepted == 2 && in_array($booking->status, [1, 2, 3])) {
        return $this->responseJson(false, 403, 'Already Accepted', []);
    }

    // Check if the booking was canceled by the customer
    if (!$booking->driver_id && $booking->is_accepted == 1 && $booking->status == 7) {
        return $this->responseJson(false, 403, 'This Booking Is Canceled By Customer', []);
    }

    $fcmTokens = $booking->users?->device_token;
    $verificationCode = rand(1000, 9999);

    DB::beginTransaction();

    try {
        if ($request->is_accepted == 2) {
            // Accept the booking
            $booking->update([
                'is_accepted' => 2,
                'page_no' => 1,
                'verification_code' => $verificationCode,
                'driver_id' => auth()->user()->id,
            ]);
        }

        // Update or create booking driver status
        $booking->bookingDrivers()->updateOrCreate(
            ['booking_id' => $id],
            ['user_id' => auth()->user()->id, 'status' => $request->is_accepted]
        );

        // Log booking status change
        $this->logBookingStatus($booking, 'Your cab is on the way');

        if ($request->is_accepted == 2) {
            // If accepted, notify the user
            $plateNo = $booking?->driver?->vehicles?->first()->plate_no ?? '';
            DB::commit();

            // Send notification and notify user
            $this->sendBookingNotification($fcmTokens, $plateNo, 'Your cab is on the way');
            $this->notifyUser($booking, 'bookingaccepted', 'Booking Accepted', 'Booking accepted by ' . auth()->user()->full_name);

            return $this->responseJson(true, 200, 'Booking Accepted Successfully', new BookingResource($booking));
        } else {
            // If rejected, rollback transaction
            DB::commit();

            // Notify user of rejection
            $this->notifyUser($booking, 'bookingrejected', 'Booking Rejected', 'Booking rejected by ' . auth()->user()->full_name);

            return $this->responseJson(true, 200, 'Booking Rejected Successfully', new BookingResource($booking));
        }
    } catch (\Throwable $th) {
        DB::rollBack();
        logger($th->getMessage() . ' on ' . $th->getFile() . ' in ' . $th->getLine());
        return $this->responseJson(false, 500, 'Something Went Wrong');
    }
}

private function logBookingStatus($booking, $comment)
{
    // Log booking status
    BookingLog::create([
        'booking_id' => $booking->id,
        'user_id' => auth()->user()->id,
        'status' => 3, // Status for 'on the way'
        'comment' => $comment,
    ]);
}

private function sendBookingNotification($fcmTokens, $plateNo, $message)
{
    if (!empty($fcmTokens)) {
        $requestparamVendor = (object)[
            'body' => 'Your Vehicle No: ' . $plateNo,
            'title' => $message,
            'image' => asset('app-assets/images/Group.png'),
            'data' => 'Your Vehicle No: ' . $plateNo,
        ];

        $this->sendNotification($requestparamVendor, $fcmTokens);
    }
}

private function notifyUser($booking, $type, $title, $message)
{
    // Notify the user about the booking status
    $data = [
        'type' => $type,
        'title' => $title,
        'message' => $message,
    ];

    $booking->users->notify(new AllNotification($data));
}

*******************************************************************************************************************************************
public function cancelBooking(Request $request)
{
    // Validate the request
    $validator = Validator::make($request->all(), [
        'uuid' => 'required|uuid|exists:bookings,uuid',
        'status' => 'required|integer',
        'reason_id' => 'required|integer',
        // 'description' => 'sometimes|required',
    ]);

    if ($validator->fails()) {
        return $this->responseJson(false, 422, $validator->errors()->first(), "");
    }

    DB::beginTransaction();
    try {
        // Convert UUID to ID
        $id = uuidToId($request->uuid, 'bookings');
        $booking = Booking::findOrFail($id);

        // Update the booking status
        $booking->update([
            'status' => 1, // Assuming 1 means cancelled
            'is_accepted' => 1,
            'is_driver' => null
        ]);

        // Log the cancellation for drivers
        $booking->bookingDrivers()->updateOrCreate(['booking_id' => $id], [
            'user_id' => auth()->user()->id,
            'status' => 6 // Assuming 6 means cancelled
        ]);

        // Log the cancellation in BookingLog
        BookingLog::create([
            'booking_id' => $id,
            'user_id' => auth()->user()->id,
            'status' => 6,
            'comment' => "Ride has been cancelled by driver"
        ]);

        // Commit the transaction
        DB::commit();

        // Prepare and send notification to the user
        $fcmTokens = $booking->users?->device_token;
        $requestParamVendor = [
            'body' => 'Your ride has been cancelled',
            'title' => 'Ride Canceled',
            'data' => 'Your ride has been cancelled',
        ];
        
        // Send notification to the user
        $this->sendNotification((object)$requestParamVendor, $fcmTokens);

        // Resend booking notification to nearby drivers
        $this->resendBookingNotificationToDrivers($booking, auth()->user()->id);

        return $this->responseJson(true, 200, 'Ride cancelled successfully', new BookingResource($booking));

    } catch (\Exception $e) {
        DB::rollBack();
        logger($e->getMessage() . ' on ' . $e->getFile() . ' in ' . $e->getLine());
        return $this->responseJson(false, 500, 'Something went wrong');
    }
}

private function resendBookingNotificationToDrivers($booking, $cancelingDriverId)
{
    // Find all nearby online drivers whose documents are verified and approved
    $nearbyDrivers = Driver::where('status', 'online') // Assuming 'online' indicates the driver is available
        ->where('document_verified', 1) // Assuming this flag indicates document verification
        ->where('id', '!=', $cancelingDriverId) // Exclude the driver who cancelled the booking
        ->get();

    // Prepare the notification data
    $requestParamDrivers = [
        'body' => 'A booking has been cancelled. Please check for new opportunities.',
        'title' => 'Booking Cancelled',
        'data' => [
            'booking_id' => $booking->id,
            'message' => 'A booking has been cancelled. Please check for new opportunities.',
        ],
    ];

    // Send notifications to eligible drivers
    foreach ($nearbyDrivers as $driver) {
        if ($driver->device_token) {
            $this->sendNotification((object)$requestParamDrivers, $driver->device_token);
        }
    }
}

*******************************************************************************************************************************************
        $fcmtokens = User::role($role)->pluck('fcmtoken')->toArray();

*******************************************************************************************************************************************
****************************************Booking****************************************************************************
*******************************************************************************************************************************************
public function createBooking(Request $request)
{
    $validator = Validator::make($request->all(), [
        'fare' => 'required|numeric',
        'category_uuid' => 'required|uuid|exists:categories,uuid',
        'from_address' => 'required|array',
        'to_address' => 'required|array',
        'type' => 'required|string|in:asap,scheduled',
        'payment_mode' => 'sometimes|string|in:cash,card',
    ]);

    if ($validator->fails()) {
        return $this->responseJson(false, 422, $validator->errors()->first(), "");
    }

    $categoryId = uuidtoid($request->category_uuid, 'categories');
    $scheduledAt = $request->type == 'asap' ? Carbon::now()->addHour()->format('Y-m-d H:i:s') : $request->scheduled_at;

    $data = [
        'user_id' => auth()->user()->id,
        'fare' => $request->fare,
        'name' => $request->name ?? auth()->user()->name,
        'phone' => $request->phone ?? auth()->user()->phone,
        'is_guest' => $request->is_guest ?? false,
        'booking_id' => Str::random(9),
        'category_id' => $categoryId,
        'scheduled_at' => $scheduledAt,
        'from_address' => json_encode($request->from_address),
        'to_address' => json_encode($request->to_address),
        'distance' => 0,  // Default before calculation
        'duration' => '0', // Default before calculation
        'payment_mode' => $request->payment_mode ?? 'cash',
        'type' => $request->type,
        'is_reward' => $request->is_reward,
        'total_fare' => $request->total_fare,
    ];

    // Calculate distance and duration
    $distanceData = $this->calculateDistances($request->from_address, $request->to_address);
    if ($distanceData) {
        $data['distance'] = $distanceData['distance'];
        $data['duration'] = $distanceData['duration'];
    } else {
        return $this->responseJson(false, 500, 'Failed to calculate distance and duration');
    }

    DB::beginTransaction();

    try {
        // Store to_address into RecentSearch
        if (!empty($request->to_address)) {
            foreach ($request->to_address as $toAddress) {
                RecentSearch::create([
                    'user_id' => auth()->user()->id,
                    'address' => $toAddress['address'],
                    'latitude' => $toAddress['lat'],
                    'longitude' => $toAddress['long'],
                ]);
            }
        }

        // Create booking
        $booking = Booking::create($data);
        BookingLog::create([
            'booking_id' => $booking->id,
            'user_id' => $booking->user_id,
            'status' => 1,
            'comment' => 'Booking created successfully'
        ]);

        DB::commit();

        // Notify nearby drivers
        $this->notifyDrivers($booking);

        return $this->responseJson(true, 200, 'Booking created successfully', new BookingResource($booking));
    } catch (\Exception $e) {
        DB::rollBack();
        return $this->responseJson(false, 500, 'Booking creation failed: ' . $e->getMessage());
    }
}
############################################################################
private function notifyDrivers($booking)
{
    $fromAddress = json_decode($booking->from_address, true);
    $latitude = $fromAddress['lat'];
    $longitude = $fromAddress['long'];
    $searchRadius = getSiteSetting('search_radius') ?? 10;
    
    // Get nearby drivers based on their proximity
    $nearbyDrivers = $this->getNearbyDrivers($latitude, $longitude, $searchRadius);

    foreach ($nearbyDrivers as $driver) {
        // Check if all required documents are verified
        if ($this->areDriverDocumentsVerified($driver) &&
            $driver->vehicles->first()->category->slug == $booking->bookingCategory->slug &&
            $driver->is_online && !$this->checkDriverOngoingRide($driver->id)) {

            $fcmToken = $driver->device_token;

            $notificationData = (object)[
                'body' => 'New Booking Has Arrived',
                'title' => 'Booking Created',
                'data' => new BookingResource($booking),
                'image' => asset('app-assets/images/booking.png'), // Replace with actual image URL
            ];

            // Send notification to the driver
            $this->sendNotification($notificationData, $fcmToken);

            // Notify the driver
            $driver->notify(new AllNotification([
                'type' => 'bookingcreated',
                'title' => 'New Booking',
                'message' => 'New booking created by ' . auth()->user()->full_name,
            ]));
        }
    }
}

private function areDriverDocumentsVerified($driver)
{
    // Assuming the driver has a 'documents' relationship that returns required document types
    $requiredDocuments = [
        'vehicle_documents', 'noc_document', 'rc_document_front', 'rc_document_back', 
        'aadhar_document_front', 'aadhar_document_back', 'licence_document_front', 
        'licence_document_back', 'pan_card'
    ];

    // Loop through required documents and check if they are approved
    foreach ($requiredDocuments as $documentType) {
        $document = $driver->documents()->where('document_type', $documentType)->first();
        if (!$document || $document->status !== 'approved') {
            return false; // If any document is not approved, return false
        }
    }

    return true; // All documents are approved
}
##########################################################################
public function notifyDrivers($booking)
{
    $fromAddress = json_decode($booking->from_address, true);
    $latitude = $fromAddress['lat'];
    $longitude = $fromAddress['long'];
    $searchRadius = getSiteSetting('search_radius') ?? 10;

    // Get nearby drivers based on their proximity
    $nearbyDrivers = $this->getNearbyDrivers($latitude, $longitude, $searchRadius);

    foreach ($nearbyDrivers as $driver) {
        // Check if all required documents are verified
        if ($this->areDriverDocumentsVerified($driver) &&
            $driver->vehicles->first()->category->slug == $booking->bookingCategory->slug &&
            $driver->is_online && !$this->checkDriverOngoingRide($driver->id)) {

            $fcmToken = $driver->device_token;

            $notificationData = (object)[
                'body' => 'New Booking Has Arrived',
                'title' => 'Booking Created',
                'data' => new BookingResource($booking),
                'image' => asset('app-assets/images/booking.png'), // Replace with actual image URL
            ];

            // Send notification to the driver
            $this->sendNotification($notificationData, $fcmToken);

            // Notify the driver
            $driver->notify(new AllNotification([
                'type' => 'bookingcreated',
                'title' => 'New Booking',
                'message' => 'New booking created by ' . auth()->user()->full_name,
            ]));
        }
    }
}

private function areDriverDocumentsVerified($driver)
{
    // Define required document types
    $requiredDocuments = [
        'vehicle_documents', 'noc_document', 'rc_document_front', 'rc_document_back', 
        'aadhar_document_front', 'aadhar_document_back', 'licence_document_front', 
        'licence_document_back', 'pan_card'
    ];

    // Loop through required documents and check if they are approved
    foreach ($requiredDocuments as $documentType) {
        $document = $driver->documents()->where('document_type', $documentType)->first();
        if (!$document || $document->status !== 'approved') {
            return false; // If any document is not approved, return false
        }
    }

    return true; // All documents are approved
}

private function getNearbyDrivers($lat, $lng, int $distance)
{
    // Assuming userService is injected or accessible to get drivers by role
    $drivers = $this->userService->findUserByRole(['is_online' => true, 'is_active' => true], 'driver');

    // Filter drivers by proximity
    return $drivers->filter(function ($driver) use ($lat, $lng, $distance) {
        $driverDistance = calculateDistance($lat, $lng, $driver->latitude, $driver->longitude);
        return $driverDistance <= (int) $distance;
    });
}

private function checkDriverOngoingRide($driverId)
{
    // Assuming there is a logic to check if the driver has an ongoing ride
    return Booking::where('driver_id', $driverId)
                  ->whereIn('status', [1, 2, 3]) // Assuming 1, 2, 3 are ongoing ride statuses
                  ->exists();
}

private function sendNotification($notificationData, $fcmToken)
{
    // Send FCM notification to the driver with the provided data
    // This function will handle sending the notification
    // Implementation can vary based on how you handle notifications (Firebase or other services)
    // Example:
    FCMService::send($fcmToken, [
        'title' => $notificationData->title,
        'body' => $notificationData->body,
        'image' => $notificationData->image,
        'data' => $notificationData->data,
    ]);
}

*******************************************************************************************************************************************

  public function findDrivers(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'lat' => ['required', 'regex:/^[-]?(([0-8]?[0-9])\.(\d+))|(90(\.0+)?)$/'],
            'lng' => ['required', 'regex:/^[-]?((((1[0-7][0-9])|([0-9]?[0-9]))\.(\d+))|180(\.0+)?)$/'],
        ]);
        if ($validator->fails()) {
            return $this->responseJson(false, 422, $validator->errors()->first(), "");
        }

        try {
            $latitude = $request->lat;
            $longitude = $request->lng;
            $distance = getSiteSetting('search_radius') ?? 100;
            $locations = Location::selectRaw(
                '*,(6371 * acos(cos(radians(?)) * cos(radians(lat)) * cos(radians(lng) - radians(?)) + sin(radians(?)) * sin(radians(lat)))) AS distance',
                [$latitude, $longitude, $latitude]
            )
                ->having('distance', '<=', $distance)
                ->where(function ($q) {
                    $q->where('created_at', '>=', now()->subMinutes(5))
                        ->orWhere('updated_at', '>=', now()->subMinutes(5));
                })
                ->whereHas('user', function ($qu) {
                    $qu->where('is_online', true);
                    /* ->whereHas('deliveries',function ($qur) {
                    $qur->whereNull('accepted_at')
                    ->where('is_completed','!=',false);
                }); */
                })
                ->orderBy('distance')->get();
            return $this->responseJson(true, 200, $locations->isNotEmpty() ? 'Drivers available in your area' : 'No driver available in your area', $locations ? DriverLocationResource::collection($locations) : []);
        } catch (\Throwable $e) {
            logger($e->getMessage() . 'on' . $e->getFile() . 'in' . $e->getLine());
            return $this->responseJson(false, 500, 'Something Went Wrong');
        }
    }
*******************************************************************************************************************************************
public function findDrivers(Request $request)
{
    $validator = Validator::make($request->all(), [
        'lat' => ['required', 'regex:/^[-]?(([0-8]?[0-9])\.(\d+))|(90(\.0+)?)$/'],
        'lng' => ['required', 'regex:/^[-]?((((1[0-7][0-9])|([0-9]?[0-9]))\.(\d+))|180(\.0+)?)$/'],
    ]);

    if ($validator->fails()) {
        return $this->responseJson(false, 422, $validator->errors()->first(), "");
    }

    try {
        $latitude = $request->lat;
        $longitude = $request->lng;
        $distance = getSiteSetting('search_radius') ?? 100;

        // Google Maps Distance Matrix API
        $apiKey = config('services.google_maps.api_key'); // Add your API Key to your env file and config/services.php
        $googleMapsUrl = "https://maps.googleapis.com/maps/api/distancematrix/json?units=metric&origins={$latitude},{$longitude}&destinations=";

        // Fetching all available driver locations
        $locations = Location::whereHas('user', function ($q) {
                $q->where('is_online', true);
            })
            ->where(function ($q) {
                $q->where('created_at', '>=', now()->subMinutes(5))
                    ->orWhere('updated_at', '>=', now()->subMinutes(5));
            })
            ->get();

        if ($locations->isEmpty()) {
            return $this->responseJson(true, 200, 'No driver available in your area', []);
        }

        // Preparing Google API destinations parameter
        $destinations = $locations->map(function ($location) {
            return "{$location->lat},{$location->lng}";
        })->implode('|');

        // Make a request to Google Maps Distance Matrix API
        $googleMapsUrl .= $destinations . "&key={$apiKey}";
        $response = Http::get($googleMapsUrl);
        $data = $response->json();

        if (isset($data['rows'][0]['elements'])) {
            $distances = $data['rows'][0]['elements'];

            // Filter locations based on the distance
            $filteredLocations = [];
            foreach ($locations as $index => $location) {
                $distanceToDriver = $distances[$index]['distance']['value'] / 1000; // Convert meters to kilometers

                if ($distanceToDriver <= $distance) {
                    $filteredLocations[] = $location;
                }
            }

            return $this->responseJson(true, 200, !empty($filteredLocations) ? 'Drivers available in your area' : 'No driver available in your area', DriverLocationResource::collection(collect($filteredLocations)));
        }

        return $this->responseJson(false, 500, 'Failed to fetch data from Google Maps');
    } catch (\Throwable $e) {
        logger($e->getMessage() . ' on ' . $e->getFile() . ' in ' . $e->getLine());
        return $this->responseJson(false, 500, 'Something Went Wrong');
    }
}


****************************************************************
public function findDrivers(Request $request)
{
    // Validate the input for latitude and longitude
    $validator = Validator::make($request->all(), [
        'lat' => ['required', 'regex:/^[-]?(([0-8]?[0-9])\.(\d+))|(90(\.0+)?)$/'],
        'lng' => ['required', 'regex:/^[-]?((((1[0-7][0-9])|([0-9]?[0-9]))\.(\d+))|180(\.0+)?)$/'],
    ]);
    
    if ($validator->fails()) {
        return $this->responseJson(false, 422, $validator->errors()->first(), "");
    }

    try {
        $latitude = $request->lat;
        $longitude = $request->lng;
        $distanceRadius = getSiteSetting('search_radius') ?? 100; // Default radius if not set
        $apiKey = config('services.google_maps.api_key'); // Your Google Maps API key

        // Get nearby drivers within the specified radius and online status
        $locations = Location::whereHas('user', function ($query) {
            $query->where('is_online', true);
        })
        ->where(function ($query) {
            $query->where('created_at', '>=', now()->subMinutes(5))
                  ->orWhere('updated_at', '>=', now()->subMinutes(5));
        })
        ->get();

        $availableDrivers = collect();

        // Loop through all drivers to calculate the distance using Google Maps API
        foreach ($locations as $location) {
            $driverLat = $location->lat;
            $driverLng = $location->lng;

            // Make API call to Google Maps Distance Matrix API
            $distanceData = $this->getDrivingDistanceFromGoogle($latitude, $longitude, $driverLat, $driverLng, $apiKey);

            if ($distanceData['status'] === 'OK' && $distanceData['distance'] <= $distanceRadius) {
                $availableDrivers->push($location);
            }
        }

        return $this->responseJson(true, 200, $availableDrivers->isNotEmpty() ? 'Drivers available in your area' : 'No driver available in your area', DriverLocationResource::collection($availableDrivers));

    } catch (\Throwable $e) {
        logger($e->getMessage() . ' on ' . $e->getFile() . ' in ' . $e->getLine());
        return $this->responseJson(false, 500, 'Something Went Wrong');
    }
}

/**
 * Helper method to call Google Maps Distance Matrix API for driving distance.
 */
private function getDrivingDistanceFromGoogle($originLat, $originLng, $destLat, $destLng, $apiKey)
{
    $url = "https://maps.googleapis.com/maps/api/distancematrix/json?units=metric&origins={$originLat},{$originLng}&destinations={$destLat},{$destLng}&key={$apiKey}";

    $response = file_get_contents($url);
    $data = json_decode($response, true);

    if ($data['status'] === 'OK') {
        $element = $data['rows'][0]['elements'][0];

        return [
            'status' => $element['status'],
            'distance' => $element['distance']['value'] / 1000, // Distance in kilometers
        ];
    }

    return ['status' => 'ERROR', 'distance' => null];
}




***************************************************************************

Booking
*******************************************************************************************************************************************




let WithdrawlMoneyRequestTable = $('#withdrawlMoneyRequestTable').DataTable({
    responsive: true,
    searching: false,
    lengthChange: false,
    "language": {
        lengthMenu: "Counts per page_MENU_",
        searchPlaceholder: "Search by name"
    },
    autoWidth: false,
    processing: true,
    serverSide: true,
    ajax: {
        url: baseUrl + 'ajax/getWithdrawlMoneyRequest',
        dataType: "json",
        type: "get",
    },
    columns: withdrawlMoneyRequest,
    dom: '<".d-flex"<".col-6" l><".col-6 text-right" f>>t<".d-flex"<".col-6" i><".col-6 text-right"p>>',
    "ordering": true,
    buttons: [
        'copy', 'csv', 'excel', 'pdf', 'print'
    ],
    "fnDrawCallback": function (oSettings) {
        let pagination = $(oSettings.nTableWrapper).find('.dataTables_paginate,.dataTables_info,.dataTables_length');
        oSettings._iDisplayLength > oSettings.fnRecordsDisplay() ? pagination.hide() : pagination.show();
    },
    "createdRow": function (row, data, dataIndex) {
        $(row).addClass('manage-enable');
        if (data.is_active) {
            $(row).addClass('block-disable');
        }
    }
});


let WithdrawlMoneyRequestTable = $('#withdrawlMoneyRequestTable').DataTable({
    responsive: true,
    searching: false,
    lengthChange: false,
    "language": {
        lengthMenu: "Counts per page_MENU_",
        searchPlaceholder: "Search by name"
    },
    autoWidth: false,
    processing: true,
    serverSide: true,
    ajax: {
        url: baseUrl + 'ajax/getWithdrawlMoneyRequest',
        dataType: "json",
        type: "get",
    },
    columns: withdrawlMoneyRequest,
    dom: '<"d-flex"<"col-6" l><"col-6 text-right" Bf>>t<"d-flex"<"col-6" i><"col-6 text-right"p>>',
    buttons: [
        'copy', 'csv', 'excel', 'pdf', 'print'
    ],
    "ordering": true,
    "fnDrawCallback": function (oSettings) {
        let pagination = $(oSettings.nTableWrapper).find('.dataTables_paginate,.dataTables_info,.dataTables_length');
        oSettings._iDisplayLength > oSettings.fnRecordsDisplay() ? pagination.hide() : pagination.show();
    },
    "createdRow": function (row, data, dataIndex) {
        $(row).addClass('manage-enable');
        if (data.is_active) {
            $(row).addClass('block-disable');
        }
    }
});

*******************************************************************************************************************************************

<div class="card-content collapse show">
                            <div class="card-body">
                                <table class="table table-striped table-bordered withdrawlMoneyRequestTable"
                                    id="withdrawlMoneyRequestTable">
                                    <thead>
                                        <tr>
                                            <th>{{ __('Sr. No.') }}</th>
                                            <th>{{ __('Driver') }}</th>
                                            <th>{{ __('Transaction Type') }}</th>
                                            <th>{{ __('Comment') }}</th>
                                            <th>{{ __('Amount') }}</th>
                                            <th>{{ __('Request Amount') }}</th>
                                            <th>{{ __('Date') }}</th>
                                            <th>{{ __('STATUS') }}</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                    </tbody>
                                </table>
                            </div>
                        </div>
*******************************************************************************************************************************************

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.3.6/js/dataTables.buttons.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.3.6/js/buttons.flash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.3.6/js/buttons.html5.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.3.6/js/buttons.print.min.js"></script>

<link rel="stylesheet" href="https://cdn.datatables.net/1.11.5/css/jquery.dataTables.min.css">
<link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.3.6/css/buttons.dataTables.min.css">


let WithdrawlMoneyRequestTable = $('#withdrawlMoneyRequestTable').DataTable({
    responsive: true,
    searching: false,
    lengthChange: false,
    "language": {
        lengthMenu: "Counts per page_MENU_",
        searchPlaceholder: "Search by name"
    },
    autoWidth: false,
    processing: true,
    serverSide: true,
    ajax: {
        url: baseUrl + 'ajax/getWithdrawlMoneyRequest',
        dataType: "json",
        type: "get",
    },
    columns: withdrawlMoneyRequest,
    dom: '<"d-flex"<"col-6" l><"col-6 text-right" Bf>>t<"d-flex"<"col-6" i><"col-6 text-right"p>>',
    buttons: [
        {
            extend: 'copyHtml5',
            text: 'Copy'
        },
        {
            extend: 'csvHtml5',
            text: 'Export CSV'
        },
        {
            extend: 'excelHtml5',
            text: 'Export Excel'
        },
        {
            extend: 'pdfHtml5',
            text: 'Export PDF'
        },
        {
            extend: 'print',
            text: 'Print'
        }
    ],
    "ordering": true,
    "fnDrawCallback": function (oSettings) {
        let pagination = $(oSettings.nTableWrapper).find('.dataTables_paginate,.dataTables_info,.dataTables_length');
        oSettings._iDisplayLength > oSettings.fnRecordsDisplay() ? pagination.hide() : pagination.show();
    },
    "createdRow": function (row, data, dataIndex) {
        $(row).addClass('manage-enable');
        if (data.is_active) {
            $(row).addClass('block-disable');
        }
    }
});


*******************************************************************************************************************************************

function changeStatus(selector) {

    var $this = selector;
    console.log($this.is(':checkbox'));
    if ($this.is(':checkbox')) {
        var state = $this.prop('checked') == true ? 1 : 0;
    } else {
        var state = $this.data('status');
    }
    var uuid = $this.data('uuid');
    if ($this.hasClass('changeUserBlock')) {
        var value = {
            'is_blocked': state
        };
    } else if ($this.hasClass('changePaymentStatus')) {
        var value = {
            'is_paid': state
        };
    } else if ($this.hasClass('changeDocumentStatus')) {
        var value = {
            'status': state,
            'user_id': $this.data('user-uuid')
        };
    } else if ($this.hasClass('changeTransactionStatus')) {
        var value = {
            'status': state,
            // 'user_id': $this.data('user-uuid')
        };
    } else {
        var value = {
            'is_active': state
        };
    }

    // console.log(value);
    // alert(value);
    var find = $this.data('table');
    var message = $this.data('message') ?? 'test message';
    Swal.fire({
        title: 'Are you sure you want to change the status?',
        text: 'The status will be changed',
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#3085d6',
        cancelButtonColor: '#d33',
        confirmButtonText: 'Yes, change it!'
    }).then((result) => {
        if (result.isConfirmed) {
            $.ajax({
                type: "put",
                url: baseUrl + 'ajax/updateStatus',
                data: { 'uuid': uuid, 'find': find, ...value },
                cache: false,
                dataType: "json",
                beforeSend: function () {

                },
                success: function (response) {
                    if (response.status) {
                        Swal.fire({
                            icon: 'success',
                            title: 'Status Updated!',
                            showConfirmButton: false,
                            timer: 1500
                        });
                        $this.data('message', message == 'deactive' ? 'active' : 'deactive');
                        if ($this.parent().hasClass('inTable')) {
                            $this.parent().closest('tr.manage-enable').toggleClass('block-disable');
                            let divRight = $this.parent().parent().siblings().find('div.dot-right');
                            divRight.hasClass('pe-none') ? divRight.removeClass('pe-none') : divRight.addClass('pe-none');
                        } else {
                            if ($this.is(':checkbox')) {
                                $this.parent().closest('div.manage-data').toggleClass('block-disable');
                                let divRight = $this.parent().closest('div.dot-right');
                                divRight.hasClass('pe-none') ? divRight.removeClass('pe-none') : divRight.addClass('pe-none');
                            }
                            if ($this.hasClass('changeDocumentStatus')) {
                                $this.parent().parent().hide();
                            }
                        }
                        if ($this.is(':checkbox')) {
                            $this.parent().find('label').text(state ? 'Active' : 'Inactive').css('color', state ? 'green' : 'red');
                        } else {
                            location.reload();
                        }
                    } else {
                        Swal.fire({
                            icon: 'error',
                            title: 'We are facing some technical issue now.',
                            showConfirmButton: false,
                            timer: 1500
                        })

                        if ($this.is(':checkbox')) {
                            $this.prop('checked', !state);
                        }

                    }
                },
                error: function (response) {
                    Swal.fire({
                        icon: 'error',
                        title: 'We are facing some technical issue now. Please try again after some time',
                        showConfirmButton: false,
                        timer: 1500
                    })
                    $this.prop('checked', !state);
                }
                /* ,
                complete: function(response){
                    location.reload();
                } */
            });
        } else {
            $this.prop('checked', !state);
        }

    });
}
**********************************************

$(document).ready(function () {
    // Show the tab based on the URL hash
    var hash = window.location.hash;
    if (hash) {
        $('#myTab a[href="' + hash + '"]').tab('show');
    } else {
        // Default to the first tab if no hash is present
        $('#myTab a:first').tab('show');
    }

    // Update the URL hash when a tab is clicked
    $('#myTab a').on('click', function (e) {
        e.preventDefault();
        var tabId = $(this).attr('href');
        window.location.hash = tabId;
        $(this).tab('show');
    });
});

**********************************************

// Store the active tab in localStorage
$(document).ready(function () {
    // When a tab is clicked, store its ID in localStorage
    $('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        var activeTab = $(e.target).attr('href');
        localStorage.setItem('activeTab', activeTab);
    });

    // On page load, check if there is a saved active tab and show it
    var activeTab = localStorage.getItem('activeTab');
    if (activeTab) {
        $('a[href="' + activeTab + '"]').tab('show');
    }
});


// Clear localStorage on logout or page unload
$(window).on('unload', function () {
    localStorage.removeItem('activeTab');
});

***********************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
*******************************************************************************************************************************************
