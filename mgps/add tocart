


try {
    const findWallet = await walletModel.findOne({ member_id: member_ObjectId }).lean();

    if (findWallet && findWallet.amount !== null && findWallet.amount !== undefined && findWallet.amount < total_price) {
        return res.status(StatusCodes.BAD_REQUEST).json({
            message: MESSAGE.custom("Insufficient balance! Please add money to your wallet."),
        });
    }

    const orderPayload = {
        member_ObjectId,
        orders,
        total_price,
        tax,
        platformCharges,
        paybleAmount,
        billing_name,
        billing_address,
        country,
        state,
        city
    };

    let purchaseInstances = await purchaseModel.findOne({ member_ObjectId });

    if (purchaseInstances) {
        orders.forEach(newOrder => {
            const existingOrder = purchaseInstances.orders.find(order => order.dog_ObjectId === newOrder.dog_ObjectId);
            
            if (existingOrder) {
                existingOrder.unit_qty += newOrder.unit_qty;
                existingOrder.total_unit_price = existingOrder.unit_qty * existingOrder.unit_price; // Correct total price update
            } else {
                purchaseInstances.orders.push({
                    dog_ObjectId: newOrder.dog_ObjectId,
                    unit_qty: newOrder.unit_qty,
                    unit_price: newOrder.unit_price,
                    total_unit_price: newOrder.total_unit_price
                });
            }
        });

        await purchaseInstances.save();
        console.log("Member orders updated successfully.");
    } else {
        purchaseInstances = await purchaseModel.create(orderPayload);
    }

    const orderInstances = await orderModel.create(orderPayload);

    // Update wallet only after order placement is confirmed
    await walletUpdate(member_ObjectId, total_price);

    await orderLogsModel.create(orderPayload);
    await addToCartModel.deleteMany({ member_ObjectId });

    return res.status(200).json({
        message: MESSAGE.custom("Order placed successfully!"),
        result: orderInstances
    });

} catch (error) {
    console.error(error);
    return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
        message: "An error occurred while updating the cart.",
        error
    });
}











{
        "member_ObjectId": "67bef37dc34ccc925695635d",
        "orders": [
            {
                "dog_ObjectId": "67dd5eb505dc63b6cecc89f3",
                "unit_qty": 2,
                "unit_price": 12,
                "total_unit_price": 36,
                "_id": "67ed0577349b81df3c31214a",
                "id": "67ed0577349b81df3c31214a"
            },
{
                "dog_ObjectId": "67dd705d16992f8dada2376f",
                "unit_qty": 2,
                "unit_price": 12,
                "total_unit_price": 36,
                "_id": "67ed0577349b81df3c31214a",
                "id": "67ed0577349b81df3c31214a"
            }
        ],
        "total_price": 22.11,
        "tax": 5
}




















try {
		const findWallet = await walletModel.findOne({ member_id: member_ObjectId }).lean();

		if (findWallet && findWallet.amount !== null && findWallet.amount !== undefined && findWallet.amount < total_price) {
			return res.status(StatusCodes.BAD_REQUEST).json({
				message: MESSAGE.custom("Insufficient balance! Please add money to your wallet."),
			});
		}

		const orderPayload = {
			member_ObjectId: member_ObjectId,
			orders: orders,
			total_price: total_price,
			tax: tax,
			platformCharges: platformCharges,
			paybleAmount: paybleAmount,
			billing_name: billing_name,
			billing_address: billing_address,
			country: country,
			state: state,
			city: city
		};

		let purchaseInstances = await purchaseModel.findOne({ member_ObjectId: member_ObjectId });

		if (purchaseInstances) {
			const order = purchaseInstances.orders.find(order => order.dog_ObjectId === orders.dog_ObjectId);

			if (order) {
				// Update existing order quantity
				order.unit_qty += orders.unit_qty;
				order.total_unit_price = order.total_unit_price; // Update total price
			} else {
				// Create new order object
				const newOrder = {
					dog_ObjectId: orders.dog_ObjectId,
					unit_qty: orders.unit_qty,
					unit_price: orders.unit_price, // Assuming a fixed price, adjust as necessary
					total_unit_price: orders.total_unit_price // Calculate total price
				};
				purchaseInstances.orders.push(newOrder);
			}
			await purchaseInstances.save(); // Save the updated purchase document
			console.log("Member orders updated successfully.");
		} else {
			purchaseInstances = await purchaseModel.create(orderPayload);
		}

		const orderInstances = await orderModel.create(orderPayload);
		walletUpdate(member_ObjectId, total_price); // Update wallet balance after successful order placement
		await orderLogsModel.create(orderPayload);
		await addToCartModel.deleteMany({ member_ObjectId: member_ObjectId });

		return res.status(200).json({
			message: MESSAGE.custom("Order placed successfully!"),
			result: orderInstances
		});

	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: "An error occurred while updating the cart.",
			error: error
		});
	}
