







[
        {
            "content": {
                "description": null,
                "upload_date_time": null,
                "files": []
            },
            "_id": "68866d8a73f5f8562928ca52",
            "competition_object_id": "686511f355f17472d78fac58",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "686511f355f17472d78fac5a",
            "competition_name": "Annual Coding Challenge2",
            "round_no": 2,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": null,
            "participant_payment_intant_id": null,
            "transaction_object_id": null,
            "status": "PARTICIPATED",
            "createdAt": "2025-07-27T18:18:50.060Z",
            "updatedAt": "2025-07-27T18:18:50.079Z",
            "__v": 0,
            "id": "68866d8a73f5f8562928ca52"
        },
        {
            "content": {
                "description": null,
                "upload_date_time": null,
                "files": []
            },
            "_id": "68866d8a73f5f8562928ca59",
            "competition_object_id": "686511f355f17472d78fac58",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "686511f355f17472d78fac5b",
            "competition_name": "Annual Coding Challenge2",
            "round_no": 3,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": null,
            "participant_payment_intant_id": null,
            "transaction_object_id": null,
            "status": "PARTICIPATING",
            "createdAt": "2025-07-27T18:18:50.077Z",
            "updatedAt": "2025-07-27T18:18:50.077Z",
            "__v": 0,
            "id": "68866d8a73f5f8562928ca59"
        }
    ]



export const getCompetitionDetails = async (req: Request, res: Response): Promise<any> => {
	try {
		const { id } = req.params;
		const competition = await CompetitionModel.findById(id).populate('competition_type')
			.populate('created_by')
			.populate('creator_company')
			.populate({
				path: 'rounds.additional_vote_package'
			}).lean();

		if (!competition) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: "Competition not found",
			});
		}
		const userDetails = await getDetailsByEmail(req.user.email);

		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.'
			});
		}
		// Format competition response
		const competitionDetails = await formatCompetitionResponse(competition, userDetails);

		console.log("competitionDetails", competitionDetails);


		// Find participants by competition
		const findParticipantsByCompetition = await ParticipantModel.find({
			competition_object_id: id,
			participant_object_id: userDetails?._id,
			status: { $in: ['PARTICIPATING', 'PARTICIPATED'] },
			round_no: competitionDetails?.current_round
		})
			.populate([
				{ path: 'transaction_object_id' },
				{ path: 'round_object_id' }
			])
			.lean();

		// Initialize variables
		let participantCompetition = false;
		let participantTransactionDetails = [];

		// Check if participants were found
		if (findParticipantsByCompetition && findParticipantsByCompetition.length > 0) {
			participantCompetition = true; // Set to true if participants are found
			participantTransactionDetails = findParticipantsByCompetition.map(participant => participant.transaction_object_id);
		}

		// Update competitionDetails object
		competitionDetails.participantCompetition = participantCompetition;
		competitionDetails.participantTransactionDetails = participantTransactionDetails;

		console.log("----------competitionDetails", competitionDetails.current_round);
		console.log("findParticipantsByCompetition------", findParticipantsByCompetition);


		return res.status(StatusCodes.OK).json({
			message: MESSAGE.get.succ,
			Result: competitionDetails
		});
	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error
		});
	}
};






____________________________________________________------------------------------------------------------------------------------------------------------------------________________________

import { Request, Response } from "express";
import CompetitionModel from "../models/Competition"; // Adjust path as needed
import dayjs from "dayjs";
import duration from "dayjs/plugin/duration";
dayjs.extend(duration);

// Type for simplified round info
interface RoundInfo {
	status: 'ongoing' | 'upcoming';
	time_status: string;
	round: any;
}

const getTimeDifferenceMessage = (startDate: string): string => {
	const diffMs = dayjs(startDate).diff(dayjs());
	const dur = dayjs.duration(diffMs);

	if (diffMs <= 0) return "Started";
	return `Starts in ${dur.days()}d ${dur.hours()}h ${dur.minutes()}m`;
};

const findCurrentOrUpcomingRound = (rounds: any[]): RoundInfo | null => {
	const now = dayjs();

	// 1. Find ongoing round
	const ongoing = rounds.find(round => {
		const start = dayjs(round.start_date_time);
		const end = dayjs(round.end_date_time);
		return now.isAfter(start) && now.isBefore(end);
	});

	if (ongoing) {
		return {
			status: 'ongoing',
			time_status: 'Ongoing now',
			round: ongoing,
		};
	}

	// 2. Sort and find nearest upcoming round
	const upcoming = rounds
		.filter(round => dayjs(round.start_date_time).isAfter(now))
		.sort((a, b) => dayjs(a.start_date_time).diff(dayjs(b.start_date_time)))[0];

	if (upcoming) {
		return {
			status: 'upcoming',
			time_status: getTimeDifferenceMessage(upcoming.start_date_time),
			round: upcoming,
		};
	}

	return null;
};

export const currentRound = async (req: Request, res: Response): Promise<void> => {
	try {
		const competitionId = "6864d6a4f450a36e6f51a53d"; // TODO: make dynamic if needed
		const competition = await CompetitionModel.findById(competitionId);

		if (!competition || !competition.rounds?.length) {
			return res.status(404).json({ message: "No rounds found." });
		}

		const result = findCurrentOrUpcomingRound(competition.rounds);

		if (!result) {
			return res.status(404).json({ message: "No current or upcoming rounds available." });
		}

		res.status(200).json(result);
	} catch (error) {
		console.error("Error in currentRound:", error);
		res.status(500).json({ message: "Internal server error", error });
	}
};










import { Request, Response } from "express";
import CompetitionModel from "../models/Competition"; // Adjust as needed
import dayjs from "dayjs";
import duration from "dayjs/plugin/duration";

dayjs.extend(duration);

export const currentRound = async (req: Request, res: Response): Promise<any> => {
	try {
		const competition = await CompetitionModel.findById("6864d6a4f450a36e6f51a53d");

		if (!competition || !competition.rounds || competition.rounds.length === 0) {
			return res.status(404).json({ message: "No rounds found" });
		}

		const now = new Date();

		// Try to find ongoing round
		let round = competition.rounds.find(r => {
			const start = new Date(r.start_date_time);
			const end = new Date(r.end_date_time);
			return start <= now && now <= end;
		});

		if (round) {
			return res.status(200).json({
				status: "ongoing",
				time_status: "Ongoing now",
				round
			});
		}

		// If no ongoing, find nearest upcoming
		const upcomingRounds = competition.rounds
			.filter(r => new Date(r.start_date_time) > now)
			.sort((a, b) => new Date(a.start_date_time).getTime() - new Date(b.start_date_time).getTime());

		if (upcomingRounds.length === 0) {
			return res.status(404).json({ message: "No upcoming rounds available" });
		}

		const upcoming = upcomingRounds[0];
		const timeUntil = dayjs(upcoming.start_date_time).diff(dayjs(), 'millisecond');
		const durationObj = dayjs.duration(timeUntil);

		return res.status(200).json({
			status: "upcoming",
			time_status: `Starts in ${durationObj.days()}d ${durationObj.hours()}h ${durationObj.minutes()}m`,
			round: upcoming
		});
	} catch (error) {
		console.error("Error determining current/upcoming round:", error);
		return res.status(500).json({ message: "Internal server error" });
	}
};










"rounds": [
        {
            "round_no": 1,
            "price": 100,
            "start_date_time": "2025-06-15T10:00:00.000Z",
            "end_date_time": "2025-07-20T12:00:00.000Z",
            "additional_vote_package": "68495783b453f6a14433bc85",
            "checkpoints": "Checkpoint 1 details",
            "free_voting_duration": 60,
            "no_of_participant_proceeding": 10,
            "_id": "6864d6a4f450a36e6f51a53e"
        },
        {
            "round_no": 2,
            "price": 150,
            "start_date_time": "2025-07-20T10:00:00.000Z",
            "end_date_time": "2025-07-21T12:00:00.000Z",
            "additional_vote_package": "68540f999c1c30cc24e04563",
            "checkpoints": "Checkpoint 2 details",
            "free_voting_duration": 45,
            "no_of_participant_proceeding": 8,
            "_id": "6864d6a4f450a36e6f51a53f"
        },
        {
            "round_no": 3,
            "price": 200,
            "start_date_time": "2025-07-25T10:00:00.000Z",
            "end_date_time": "2025-07-28T12:00:00.000Z",
            "additional_vote_package": "68495ed8e1f2f08d1c0053ec",
            "checkpoints": "Checkpoint 3 details",
            "free_voting_duration": 30,
            "no_of_participant_proceeding": 5,
            "_id": "6864d6a4f450a36e6f51a540"
        }
    ],

export const currentRound = async (req: Request, res: Response): Promise<any> => {
	const fetchCurrentRounds = await CompetitionModel.findById("6864d6a4f450a36e6f51a53d"); // Await the result of the asynchronous operation
	console.log("Fetched current rounds:", fetchCurrentRounds);

	currentRound.rounds.forEach(round => {
		console.log(`Round No: ${round.round_no}, Price: ${round.price}`);
	});

	// Accessing the first round directly
	const firstRound = data.rounds[0];
	console.log(`First Round Checkpoints: ${firstRound.checkpoints}`);

	// Send the fetched data as a response
	res.status(200).json(fetchCurrentRounds);
}
