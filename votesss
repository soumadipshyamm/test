
















#####################################################################################################################################

export const participantParticipatedCompetitionsList = async (req: Request, res: Response): Promise<any> => {
	const user = await getDetailsByEmail(req.user.email);
	const competitionId = req.params.competition_id;
	const round_no = req.params.round_no;
	const round_object_id = req.params.round_object_id;
	// Check if user is authenticated
	if (!user) {
		return res.status(StatusCodes.UNAUTHORIZED).json({
			message: 'User not authenticated.'
		});
	}

	const participantId = user._id;
	// Build the query object
	const query: any = {
		participant_object_id: participantId,
		status: { $in: [PARTICIPATION_STATUS.participated, PARTICIPATION_STATUS.participating] }
	};

	// Add competition ID to the query if it exists
	if (competitionId) {
		query.competition_object_id = competitionId;
	}
	if (round_object_id) {
		// query.round_no = round_no;
		query.round_object_id = round_object_id;
	}

	// Fetch participant competitions based on the constructed query
	const fetchParticipant = await ParticipantModel.find(query).lean();
	// Check if any competitions were found
	if (!fetchParticipant || fetchParticipant.length === 0) {
		return res.status(StatusCodes.NOT_FOUND).json({
			message: "No competitions found for this participant.",
			result: []
		});
	}

	// Return the fetched competitions
	return res.status(StatusCodes.OK).json({
		message: "Fetched participant competitions successfully.",
		result: fetchParticipant
	});
};

this is my code rember this


this is a  "competition_object_id": {
                "_id": "686511f355f17472d78fac58",
                "name": "Annual Coding Challenge2",
                "challenge_start_date": "2025-07-18T10:00:00.000Z",
                "challenge_end_date": "2025-08-30T18:00:00.000Z",
                "competition_type": "686f9c8144c81078efd12346",
                "no_of_rounds": 3,
                "rounds": [
                    {
                        "round_no": 1,
                        "price": 100,
                        "start_date_time": "2025-07-17T10:00:00.000Z",
                        "end_date_time": "2025-07-17T12:00:00.000Z",
                        "additional_vote_package": "68495783b453f6a14433bc85",
                        "checkpoints": "Checkpoint 1 details",
                        "free_voting_duration": 60,
                        "no_of_participant_proceeding": 10,
                        "_id": "686511f355f17472d78fac59"
                    },
                    {
                        "round_no": 2,
                        "price": 150,
                        "start_date_time": "2025-07-20T10:00:00.000Z",
                        "end_date_time": "2025-07-21T12:00:00.000Z",
                        "additional_vote_package": "68495ed8e1f2f08d1c0053ec",
                        "checkpoints": "Checkpoint 2 details",
                        "free_voting_duration": 45,
                        "no_of_participant_proceeding": 8,
                        "_id": "686511f355f17472d78fac5a"
                    },
                    {
                        "round_no": 3,
                        "price": 200,
                        "start_date_time": "2025-07-25T10:00:00.000Z",
                        "end_date_time": "2025-07-30T12:00:00.000Z",
                        "additional_vote_package": "68495ed8e1f2f08d1c0053ec",
                        "checkpoints": "Checkpoint 3 details",
                        "free_voting_duration": 30,
                        "no_of_participant_proceeding": 5,
                        "_id": "686511f355f17472d78fac5b"
                    }
                ],
                "feature_image": "https://example.com/image.png",
                "description": "This is the annual coding competition.",
                "round_checkpoint_start_visibility": true,
                "no_of_winner": 3,
                "prizes": [
                    {
                        "name": "First Prize",
                        "type": "money",
                        "value": "500",
                        "_id": "686511f355f17472d78fac5c"
                    },
                    {
                        "name": "Second Prize",
                        "type": "gift",
                        "value": "Gift Card",
                        "_id": "686511f355f17472d78fac5d"
                    },
                    {
                        "name": "Third Prize",
                        "type": "money",
                        "value": "200",
                        "_id": "686511f355f17472d78fac5e"
                    }
                ],
                "status": "ACTIVE",
                "file_type": [
                    "JPEG",
                    "PNG",
                    "MP4"
                ],
                "created_by": "68765209c6ff9e5cb7072a90",
                "creator_company": "685019ec02dc1f27d38947d5",
                "creator_description": "Sample",
                "createdAt": "2025-07-02T11:03:15.125Z",
                "updatedAt": "2025-07-02T11:03:15.125Z",
                "__v": 0
            },




and ther is a participant 
"result": [
        {
            "_id": "68866d8773f5f8562928ca34",
            "competition_object_id": "686511f355f17472d78fac58",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "686511f355f17472d78fac59",
            "competition_name": "Annual Coding Challenge2",
            "round_no": 1,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": "succeeded",
            "participant_payment_intant_id": "pi_3Rps1mBuHqQNZg722SxsZWFo",
            "transaction_object_id": "688788e2287424a0e2778d55",
            "content": {
                "description": null,
                "upload_date_time": null,
                "files": []
            },
            "status": "PARTICIPATED",
            "createdAt": "2025-07-27T18:18:47.627Z",
            "updatedAt": "2025-07-28T15:03:33.203Z",
            "__v": 0
        },
        {
            "_id": "68866d8a73f5f8562928ca52",
            "competition_object_id": "686511f355f17472d78fac58",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "686511f355f17472d78fac5a",
            "competition_name": "Annual Coding Challenge2",
            "round_no": 2,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": null,
            "participant_payment_intant_id": null,
            "transaction_object_id": null,
            "content": {
                "description": null,
                "upload_date_time": null,
                "files": []
            },
            "status": "PARTICIPATED",
            "createdAt": "2025-07-27T18:18:50.060Z",
            "updatedAt": "2025-07-27T18:18:50.079Z",
            "__v": 0
        },
        {
            "_id": "68866d8a73f5f8562928ca59",
            "competition_object_id": "686511f355f17472d78fac58",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "686511f355f17472d78fac5b",
            "competition_name": "Annual Coding Challenge2",
            "round_no": 3,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": null,
            "participant_payment_intant_id": null,
            "transaction_object_id": null,
            "content": {
                "description": null,
                "upload_date_time": null,
                "files": []
            },
            "status": "PARTICIPATING",
            "createdAt": "2025-07-27T18:18:50.077Z",
            "updatedAt": "2025-07-27T18:18:50.077Z",
            "__v": 0
        }
    ]
}

make a function for participant list which have upcomming, ongoing, completed Competitions Round , 
checking in competition_object_id."rounds": [
        {"start_date_time": "2025-07-17T10:00:00.000Z",
            "end_date_time": "2025-07-17T12:00:00.000Z",}]   to check currecnt date
#####################################################################################################################################


import { Request, Response } from "express";
import { StatusCodes } from "http-status-codes";
import dayjs from "dayjs";
import duration from "dayjs/plugin/duration";
import CompetitionModel from "../models/Competition";
import ParticipantModel from "../models/Participant";
import { getDetailsByEmail } from "../services/userService";
import { formatCompetitionResponse } from "../utils/formatters";
import MESSAGE from "../constants/messages";

dayjs.extend(duration);

// Interfaces
interface IRound {
	_id: string;
	round_no: number;
	start_date_time: string;
	end_date_time: string;
	[key: string]: any;
}

interface IParticipant {
	_id: string;
	round_no: number;
	transaction_object_id?: any;
	round_object_id?: any;
	[key: string]: any;
}

interface ICompetition {
	_id: string;
	rounds: IRound[];
	[key: string]: any;
}

export const getCompetitionDetails = async (req: Request, res: Response): Promise<void> => {
	try {
		const { id } = req.params;

		// Fetch competition
		const competition: ICompetition | null = await CompetitionModel.findById(id)
			.populate('competition_type')
			.populate('created_by')
			.populate('creator_company')
			.populate({ path: 'rounds.additional_vote_package' })
			.lean();

		if (!competition) {
			res.status(StatusCodes.NOT_FOUND).json({ message: "Competition not found" });
			return;
		}

		// Get user
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			res.status(StatusCodes.UNAUTHORIZED).json({ message: "User not authenticated" });
			return;
		}

		// Determine current or upcoming round
		const now = dayjs();
		const sortedRounds: IRound[] = (competition.rounds || []).sort((a, b) =>
			dayjs(a.start_date_time).diff(dayjs(b.start_date_time))
		);

		let roundStatus: "ongoing" | "upcoming" | "none" = "none";
		let currentRound: IRound | undefined = sortedRounds.find(r =>
			dayjs(r.start_date_time).isBefore(now) && dayjs(r.end_date_time).isAfter(now)
		);

		if (!currentRound) {
			currentRound = sortedRounds.find(r => dayjs(r.start_date_time).isAfter(now));
			if (currentRound) roundStatus = "upcoming";
		} else {
			roundStatus = "ongoing";
		}

		// Time status
		let time_status = "Ongoing now";
		if (roundStatus === "upcoming" && currentRound) {
			const ms = dayjs(currentRound.start_date_time).diff(now);
			const dur = dayjs.duration(ms);
			time_status = `Starts in ${dur.days()}d ${dur.hours()}h ${dur.minutes()}m`;
		}

		// Format competition response
		const competitionDetails: any = await formatCompetitionResponse(competition, userDetails);
		competitionDetails.current_round = currentRound?.round_no ?? null;
		competitionDetails.round_status = roundStatus;
		competitionDetails.time_status = time_status;

		// Fetch participant data
		const participants: IParticipant[] = await ParticipantModel.find({
			competition_object_id: id,
			participant_object_id: userDetails._id,
			status: { $in: ['PARTICIPATED', 'PARTICIPATING'] },
			round_no: currentRound?.round_no
		})
			.populate([{ path: 'transaction_object_id' }, { path: 'round_object_id' }])
			.lean();

		competitionDetails.participantCompetition = participants.length > 0;
		competitionDetails.participantTransactionDetails = participants.map(p => p.transaction_object_id);
		competitionDetails.participantDetails = participants;

		res.status(StatusCodes.OK).json({
			message: MESSAGE.get.succ,
			Result: competitionDetails
		});
	} catch (error) {
		console.error("Error in getCompetitionDetails:", error);
		res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error
		});
	}
};









import { Request, Response } from "express";
import { StatusCodes } from "http-status-codes";
import dayjs from "dayjs";
import duration from "dayjs/plugin/duration";
dayjs.extend(duration);

import CompetitionModel from "../models/Competition";
import ParticipantModel from "../models/Participant";
import { getDetailsByEmail } from "../helpers/userHelper";
import { formatCompetitionResponse } from "../helpers/formatters";
import { MESSAGE } from "../constants";

export const getCompetitionDetails = async (req: Request, res: Response): Promise<any> => {
	try {
		const { id } = req.params;

		// Fetch competition
		const competition = await CompetitionModel.findById(id)
			.populate('competition_type')
			.populate('created_by')
			.populate('creator_company')
			.populate({
				path: 'rounds.additional_vote_package'
			}).lean();

		if (!competition) {
			return res.status(StatusCodes.NOT_FOUND).json({ message: "Competition not found" });
		}

		// Authenticated user
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated.' });
		}

		// Determine current or upcoming round
		const now = dayjs();
		const sortedRounds = competition.rounds.sort((a, b) =>
			dayjs(a.start_date_time).unix() - dayjs(b.start_date_time).unix()
		);

		let currentRound = sortedRounds.find(r =>
			now.isAfter(dayjs(r.start_date_time)) && now.isBefore(dayjs(r.end_date_time))
		);

		let roundStatus = "ongoing";
		let timeStatus = "Ongoing now";

		if (!currentRound) {
			currentRound = sortedRounds.find(r => dayjs(r.start_date_time).isAfter(now));
			if (currentRound) {
				roundStatus = "upcoming";
				const diff = dayjs(currentRound.start_date_time).diff(now);
				const dur = dayjs.duration(diff);
				timeStatus = `Starts in ${dur.days()}d ${dur.hours()}h ${dur.minutes()}m`;
			}
		}

		// Format competition response
		const competitionDetails = await formatCompetitionResponse(competition, userDetails);
		competitionDetails.current_round = currentRound?.round_no ?? null;
		competitionDetails.current_round_object = currentRound ?? null;
		competitionDetails.round_status = roundStatus;
		competitionDetails.time_status = timeStatus;

		// Fetch participant record for this round
		const findParticipantsByCompetition = await ParticipantModel.find({
			competition_object_id: id,
			participant_object_id: userDetails._id,
			status: { $in: ['PARTICIPATING', 'PARTICIPATED'] },
			round_no: currentRound?.round_no
		})
			.populate([
				{ path: 'transaction_object_id' },
				{ path: 'round_object_id' }
			])
			.lean();

		competitionDetails.participantCompetition = findParticipantsByCompetition.length > 0;
		competitionDetails.participantTransactionDetails = findParticipantsByCompetition.map(p => p.transaction_object_id);
		competitionDetails.participantDetails = findParticipantsByCompetition;

		return res.status(StatusCodes.OK).json({
			message: MESSAGE.get.succ,
			Result: competitionDetails
		});
	} catch (error) {
		console.error("Error in getCompetitionDetails:", error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error
		});
	}
};





[
        {
            "content": {
                "description": null,
                "upload_date_time": null,
                "files": []
            },
            "_id": "68866d8a73f5f8562928ca52",
            "competition_object_id": "686511f355f17472d78fac58",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "686511f355f17472d78fac5a",
            "competition_name": "Annual Coding Challenge2",
            "round_no": 2,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": null,
            "participant_payment_intant_id": null,
            "transaction_object_id": null,
            "status": "PARTICIPATED",
            "createdAt": "2025-07-27T18:18:50.060Z",
            "updatedAt": "2025-07-27T18:18:50.079Z",
            "__v": 0,
            "id": "68866d8a73f5f8562928ca52"
        },
        {
            "content": {
                "description": null,
                "upload_date_time": null,
                "files": []
            },
            "_id": "68866d8a73f5f8562928ca59",
            "competition_object_id": "686511f355f17472d78fac58",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "686511f355f17472d78fac5b",
            "competition_name": "Annual Coding Challenge2",
            "round_no": 3,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": null,
            "participant_payment_intant_id": null,
            "transaction_object_id": null,
            "status": "PARTICIPATING",
            "createdAt": "2025-07-27T18:18:50.077Z",
            "updatedAt": "2025-07-27T18:18:50.077Z",
            "__v": 0,
            "id": "68866d8a73f5f8562928ca59"
        }
    ]



export const getCompetitionDetails = async (req: Request, res: Response): Promise<any> => {
	try {
		const { id } = req.params;
		const competition = await CompetitionModel.findById(id).populate('competition_type')
			.populate('created_by')
			.populate('creator_company')
			.populate({
				path: 'rounds.additional_vote_package'
			}).lean();

		if (!competition) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: "Competition not found",
			});
		}
		const userDetails = await getDetailsByEmail(req.user.email);

		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.'
			});
		}
		// Format competition response
		const competitionDetails = await formatCompetitionResponse(competition, userDetails);

		console.log("competitionDetails", competitionDetails);


		// Find participants by competition
		const findParticipantsByCompetition = await ParticipantModel.find({
			competition_object_id: id,
			participant_object_id: userDetails?._id,
			status: { $in: ['PARTICIPATING', 'PARTICIPATED'] },
			round_no: competitionDetails?.current_round
		})
			.populate([
				{ path: 'transaction_object_id' },
				{ path: 'round_object_id' }
			])
			.lean();

		// Initialize variables
		let participantCompetition = false;
		let participantTransactionDetails = [];

		// Check if participants were found
		if (findParticipantsByCompetition && findParticipantsByCompetition.length > 0) {
			participantCompetition = true; // Set to true if participants are found
			participantTransactionDetails = findParticipantsByCompetition.map(participant => participant.transaction_object_id);
		}

		// Update competitionDetails object
		competitionDetails.participantCompetition = participantCompetition;
		competitionDetails.participantTransactionDetails = participantTransactionDetails;

		console.log("----------competitionDetails", competitionDetails.current_round);
		console.log("findParticipantsByCompetition------", findParticipantsByCompetition);


		return res.status(StatusCodes.OK).json({
			message: MESSAGE.get.succ,
			Result: competitionDetails
		});
	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error
		});
	}
};






____________________________________________________------------------------------------------------------------------------------------------------------------------________________________

import { Request, Response } from "express";
import CompetitionModel from "../models/Competition"; // Adjust path as needed
import dayjs from "dayjs";
import duration from "dayjs/plugin/duration";
dayjs.extend(duration);

// Type for simplified round info
interface RoundInfo {
	status: 'ongoing' | 'upcoming';
	time_status: string;
	round: any;
}

const getTimeDifferenceMessage = (startDate: string): string => {
	const diffMs = dayjs(startDate).diff(dayjs());
	const dur = dayjs.duration(diffMs);

	if (diffMs <= 0) return "Started";
	return `Starts in ${dur.days()}d ${dur.hours()}h ${dur.minutes()}m`;
};

const findCurrentOrUpcomingRound = (rounds: any[]): RoundInfo | null => {
	const now = dayjs();

	// 1. Find ongoing round
	const ongoing = rounds.find(round => {
		const start = dayjs(round.start_date_time);
		const end = dayjs(round.end_date_time);
		return now.isAfter(start) && now.isBefore(end);
	});

	if (ongoing) {
		return {
			status: 'ongoing',
			time_status: 'Ongoing now',
			round: ongoing,
		};
	}

	// 2. Sort and find nearest upcoming round
	const upcoming = rounds
		.filter(round => dayjs(round.start_date_time).isAfter(now))
		.sort((a, b) => dayjs(a.start_date_time).diff(dayjs(b.start_date_time)))[0];

	if (upcoming) {
		return {
			status: 'upcoming',
			time_status: getTimeDifferenceMessage(upcoming.start_date_time),
			round: upcoming,
		};
	}

	return null;
};

export const currentRound = async (req: Request, res: Response): Promise<void> => {
	try {
		const competitionId = "6864d6a4f450a36e6f51a53d"; // TODO: make dynamic if needed
		const competition = await CompetitionModel.findById(competitionId);

		if (!competition || !competition.rounds?.length) {
			return res.status(404).json({ message: "No rounds found." });
		}

		const result = findCurrentOrUpcomingRound(competition.rounds);

		if (!result) {
			return res.status(404).json({ message: "No current or upcoming rounds available." });
		}

		res.status(200).json(result);
	} catch (error) {
		console.error("Error in currentRound:", error);
		res.status(500).json({ message: "Internal server error", error });
	}
};










import { Request, Response } from "express";
import CompetitionModel from "../models/Competition"; // Adjust as needed
import dayjs from "dayjs";
import duration from "dayjs/plugin/duration";

dayjs.extend(duration);

export const currentRound = async (req: Request, res: Response): Promise<any> => {
	try {
		const competition = await CompetitionModel.findById("6864d6a4f450a36e6f51a53d");

		if (!competition || !competition.rounds || competition.rounds.length === 0) {
			return res.status(404).json({ message: "No rounds found" });
		}

		const now = new Date();

		// Try to find ongoing round
		let round = competition.rounds.find(r => {
			const start = new Date(r.start_date_time);
			const end = new Date(r.end_date_time);
			return start <= now && now <= end;
		});

		if (round) {
			return res.status(200).json({
				status: "ongoing",
				time_status: "Ongoing now",
				round
			});
		}

		// If no ongoing, find nearest upcoming
		const upcomingRounds = competition.rounds
			.filter(r => new Date(r.start_date_time) > now)
			.sort((a, b) => new Date(a.start_date_time).getTime() - new Date(b.start_date_time).getTime());

		if (upcomingRounds.length === 0) {
			return res.status(404).json({ message: "No upcoming rounds available" });
		}

		const upcoming = upcomingRounds[0];
		const timeUntil = dayjs(upcoming.start_date_time).diff(dayjs(), 'millisecond');
		const durationObj = dayjs.duration(timeUntil);

		return res.status(200).json({
			status: "upcoming",
			time_status: `Starts in ${durationObj.days()}d ${durationObj.hours()}h ${durationObj.minutes()}m`,
			round: upcoming
		});
	} catch (error) {
		console.error("Error determining current/upcoming round:", error);
		return res.status(500).json({ message: "Internal server error" });
	}
};










"rounds": [
        {
            "round_no": 1,
            "price": 100,
            "start_date_time": "2025-06-15T10:00:00.000Z",
            "end_date_time": "2025-07-20T12:00:00.000Z",
            "additional_vote_package": "68495783b453f6a14433bc85",
            "checkpoints": "Checkpoint 1 details",
            "free_voting_duration": 60,
            "no_of_participant_proceeding": 10,
            "_id": "6864d6a4f450a36e6f51a53e"
        },
        {
            "round_no": 2,
            "price": 150,
            "start_date_time": "2025-07-20T10:00:00.000Z",
            "end_date_time": "2025-07-21T12:00:00.000Z",
            "additional_vote_package": "68540f999c1c30cc24e04563",
            "checkpoints": "Checkpoint 2 details",
            "free_voting_duration": 45,
            "no_of_participant_proceeding": 8,
            "_id": "6864d6a4f450a36e6f51a53f"
        },
        {
            "round_no": 3,
            "price": 200,
            "start_date_time": "2025-07-25T10:00:00.000Z",
            "end_date_time": "2025-07-28T12:00:00.000Z",
            "additional_vote_package": "68495ed8e1f2f08d1c0053ec",
            "checkpoints": "Checkpoint 3 details",
            "free_voting_duration": 30,
            "no_of_participant_proceeding": 5,
            "_id": "6864d6a4f450a36e6f51a540"
        }
    ],

export const currentRound = async (req: Request, res: Response): Promise<any> => {
	const fetchCurrentRounds = await CompetitionModel.findById("6864d6a4f450a36e6f51a53d"); // Await the result of the asynchronous operation
	console.log("Fetched current rounds:", fetchCurrentRounds);

	currentRound.rounds.forEach(round => {
		console.log(`Round No: ${round.round_no}, Price: ${round.price}`);
	});

	// Accessing the first round directly
	const firstRound = data.rounds[0];
	console.log(`First Round Checkpoints: ${firstRound.checkpoints}`);

	// Send the fetched data as a response
	res.status(200).json(fetchCurrentRounds);
}
