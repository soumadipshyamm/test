
  public function getFareByLocation(Request $request)

    {
        $t0 = microtime(true);

        // =========================
        // 1) Inputs & validation
        // =========================
        // dd($request->all());
        $pickupLat = (float) ($request->input('pickup.lat') ?? $request->input('lat'));
        $pickupLng = (float) ($request->input('pickup.lng') ?? $request->input('lng'));
        $radiusKm  = (int) ($request->input('radius_km') ?? 5);       // default 5km
        $avgSpeedKmph = (int) ($request->input('avg_speed_kmph') ?? 25); // realistic city avg

        if (!$pickupLat || !$pickupLng) {
            Log::warning('nearestVehicles: invalid pickup lat/lng', compact('pickupLat', 'pickupLng'));
            return $this->responseJson(false, 422, __('Invalid pickup coordinates'), []);
        }

        $distances = calculateDistances($request->pickup, $request->drop);
        $totalDistanceKm = $distances['distance'] ?? 0;
        $totalDurationMin = round($distances['duration']) ?? 0;

        $currentLat = $request->input('lat');
        $currentLng = $request->input('lng');

        // Optional route (pickup->drop) from client; else we fallback to driver->pickup
        $routeDistanceKm = $totalDistanceKm;
        $routeDurationMin =  $totalDurationMin;
        // $routeDistanceKm = (float) ($request->input('route.distance_km') ?? 0);
        // $routeDurationMin = (int) ($request->input('route.duration_min') ?? 0);


        // =========================
        // 2) Online & available drivers
        // =========================
        $driversOnlineList = $this->userService->findUserByRole([
            'is_online'  => 1,
            'is_blocked' => 0,
        ], 'driver');

        $driverIds = $driversOnlineList->pluck('id')->toArray();
        if (empty($driverIds)) {
            Log::info('nearestVehicles: no online drivers');
            return $this->responseJson(false, 200, __('No Online Drivers Available'), []);
        }

        $busyDriverIds = Booking::query()
            ->whereIn('status', [1, 2, 3, 4])
            ->where('is_accepted', 2)
            ->whereNotNull('driver_id')
            ->distinct()
            ->pluck('driver_id')
            ->toArray();

        $availableDriverIds = array_diff($driverIds, $busyDriverIds);
        if (empty($availableDriverIds)) {
            Log::info('nearestVehicles: no available drivers after excluding busy ones');
            return $this->responseJson(false, 200, __('No Available Drivers'), []);
        }

        // =========================
        // 3) Bounding-box prefilter (fast coarse filter)
        // =========================
        // ~111.32 km per degree latitude; longitude depends on latitude (cos)
        $latDelta = $radiusKm / 111.32;
        $lngDelta = $radiusKm / (111.32 * max(cos(deg2rad($pickupLat)), 0.000001));

        $minLat = $pickupLat - $latDelta;
        $maxLat = $pickupLat + $latDelta;
        $minLng = $pickupLng - $lngDelta;
        $maxLng = $pickupLng + $lngDelta;

        // =========================
        // 4) Haversine distance expr (KM) and query
        // =========================
        $earthRadius = 6371; // km
        $haversineExpr = "$earthRadius * acos(
        cos(radians(?)) * cos(radians(users.latitude)) *
        cos(radians(users.longitude) - radians(?)) +
        sin(radians(?)) * sin(radians(users.latitude))
        )";

        $bindings = [$pickupLat, $pickupLng, $pickupLat];

        $q0 = microtime(true);

        $vehicles = Vehicle::query()
            ->join('users', 'users.id', '=', 'vehicles.user_id')
            ->whereIn('vehicles.user_id', $availableDriverIds)
            ->where('vehicles.is_primary', 1)
            ->whereNotNull('users.latitude')
            ->whereNotNull('users.longitude')
            // Bounding box first (cheap)
            ->whereBetween('users.latitude', [$minLat, $maxLat])
            ->whereBetween('users.longitude', [$minLng, $maxLng])
            // Only categories with active fares
            ->whereHas('category', function ($q) {
                $q->where('is_active', 1)
                    ->whereHas('fares', fn($fq) => $fq->where('is_active', 1));
            })
            // Minimal base columns but eager relationships required by resource
            ->select('vehicles.*')
            ->selectRaw("$haversineExpr AS distance_km", $bindings)
            // NOW filter by radius using WHERE (not HAVING)
            ->whereRaw("$haversineExpr <= ?", array_merge($bindings, [$radiusKm]))
            ->with([
                'category.parent',
                'category.fares'     => fn($q) => $q->where('is_active', 1),
                'category.faresDate' => fn($q) => $q->where('is_active', 1),
                'brand',
                'car',
                'user:id,latitude,longitude',
            ])
            ->orderBy('distance_km', 'asc')
            ->get();

        // dd($vehicles);
        $q1 = microtime(true);
        // Log::debug('nearestVehicles: query runtime (ms)', ['ms' => round(($q1 - $q0) * 1000, 2)]);

        if ($vehicles->isEmpty()) {
            // Log::info('nearestVehicles: no vehicles within radius', compact('radiusKm'));
            return $this->responseJson(false, 200, __('No vehicles within radius'), []);
        }

        // =========================
        // 5) Fare cache by category (avoid repeated helper calls)
        // =========================
        $fareByCategory = [];

        $hasSpecialHelper = function_exists('getBaseFareFromSpecialTimeSlot');
        $hasRegularHelper = function_exists('getBaseFareFromTimeSlot');
        $fareByCategory = [];

        $selectAppliedFare = function ($category, $preferSpecial = false) use (&$fareByCategory, $hasSpecialHelper, $hasRegularHelper) {
            if (!$category || !$category->id) return null;
            $cid = $category->id;

            if (array_key_exists($cid, $fareByCategory)) {
                return $fareByCategory[$cid];
            }

            $faresSpecial = $category->faresDate ?? null;
            $faresRegular = $category->fares ?? null;

            $special = ($hasSpecialHelper && !empty($faresSpecial)) ? getBaseFareFromSpecialTimeSlot($faresSpecial) : null;
            $regular = ($hasRegularHelper && !empty($faresRegular)) ? getBaseFareFromTimeSlot($faresRegular) : null;
            // dd($special, $regular);
            // precedence toggle: prefer special or regular
            $applied = $preferSpecial ? ($special ?? $regular) : ($regular ?? $special);

            return $fareByCategory[$cid] = $applied;
        };

        // =========================
        // 6) Attach distance, compute fare, build list
        // =========================
        $nearestVehicles = $vehicles->map(function ($v) use ($avgSpeedKmph, $routeDistanceKm, $routeDurationMin, $selectAppliedFare) {

            // Base distance from SQL (driver -> pickup)
            $kmDriverToPickup = round((float) $v->distance_km, 3);
            $minDriverToPickup = (int) ceil(($kmDriverToPickup / max($avgSpeedKmph, 1)) * 60);

            // Prefer client-provided route, else fallback
            $totalDistanceKm  = $routeDistanceKm > 0 ? round($routeDistanceKm, 3) : $kmDriverToPickup;
            $totalDurationMin = $routeDurationMin > 0 ? (int) $routeDurationMin : $minDriverToPickup;

            // Applied fare from cache
            $appliedFare = $selectAppliedFare($v->category);

            if ($appliedFare === null) {
                // If you want to exclude vehicles with no fare, return null here and filter later
                $v->setAttribute('total_fare', 0);
                Log::debug('nearestVehicles: no applied fare for category', [
                    'category_id' => optional($v->category)->id,
                    'vehicle_id'  => $v->id
                ]);
            } else {

                info("===================================");
                info($appliedFare->base_fare);
                info($appliedFare->rate_per_km);
                info($totalDistanceKm);
                info(((float)($appliedFare->rate_per_km ?? 0) * $totalDistanceKm));
                info($appliedFare->rate_per_minute);
                info($totalDurationMin);
                info(((float)($appliedFare->rate_per_minute ?? 0) * $totalDurationMin));
                info("===================================");

                $totalFare = (float)($appliedFare->base_fare ?? 0)
                    + ((float)($appliedFare->rate_per_km ?? 0) * $totalDistanceKm)
                    + ((float)($appliedFare->rate_per_minute ?? 0) * $totalDurationMin);

                $fareWithGst = function_exists('calculateAmountWithGST')
                    ? calculateAmountWithGST($totalFare)
                    : $totalFare;
                info("*********************************************************");
                info($fareWithGst);
                info($totalFare);
                info("*********************************************************");
                $v->setAttribute('total_fare', round((float) $fareWithGst, 2));
            }



            // Base numeric values you already computed
            $km   = round((float) $totalDistanceKm, 3);
            $min  = (int) max($totalDurationMin, 0);

            // Derived units
            $meters = (int) round($km * 1000);                  // m
            $hours  = round($min / 60, 2);                      // h (2-decimal precision)

            // Friendly text (localized messages can replace hardcoded strings)
            $distanceText = $km >= 1
                ? ($km . ' km')
                : ($meters . ' m');

            $durationText = $min >= 60
                ? ($hours . ' h')
                : ($min . ' min');

            $v->setAttribute('distance', [
                // Raw numeric values
                'distance_km'   => $km,        // kilometers
                'distance_m'    => $meters,    // meters
                'duration_min'  => $min,       // minutes
                'duration_hr'   => $hours,     // hours (decimal)

                // Friendly strings
                'distance' => $distanceText,  // e.g., "3.2 km" or "850 m"
                'duration' => $durationText,  // e.g., "45 min" or "1.75 h"
            ]);


            // Attach payload for VehicleNewResource
            // $v->setAttribute('distance', [
            //     'distance' => $totalDistanceKm,   // km
            //     'duration' => $totalDurationMin,  // minutes
            // ]);
            info("===================================");
            info($v->total_fare);
            info($v);
            info("===================================");
            return $v;
        })
            // Uncomment to drop vehicles without fare:
            ->filter(fn($v) => ($v->total_fare ?? 0) > 0)
            ->values();

        $t1 = microtime(true);
        // Log::debug('nearestVehicles: total runtime (ms)', ['ms' => round(($t1 - $t0) * 1000, 2)]);
        // Log::debug('nearestVehicles: result size', ['count' => $nearestVehicles->count()]);
        info("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
        info($nearestVehicles);
        info("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");

        // =========================
        // 7) Return with your exact signature
        // =========================
        return $this->responseJson(
            true,
            200,
            __('Vehicle Found Successfully'),
            VehicleNewResource::collection($nearestVehicles)
        );
    }



*********************************************************************************************************************************************




use GuzzleHttp\Client;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

/**
 * Optimized fetch: use DB-side haversine filtering then batch Google DM only for top candidates.
 *
 * $pickup = ['lat' => float, 'lng' => float] or null
 * $drop   = ['lat' => float, 'lng' => float] or null
 * $currentLatLng = ['lat' => float, 'lng' => float] or null
 *
 * Options:
 *  - $maxCandidates: max rows to return from DB (e.g. 150)
 *  - $matrixLimit: number of nearest to call Google for (e.g. 20-50)
 *  - $searchRadiusKm: initial bounding radius (e.g. 5 or site setting)
 */
private function fetchAndComputeNearestVehicles(array $availableDriverIds, ?array $currentLatLng, $pickup, $drop, $maxCandidates = 150, $matrixLimit = 30, $searchRadiusKm = 5.0)
{
    // 1) If coordinates available, compute DB-level haversine and limit rows.
    $vehiclesQuery = Vehicle::query()
        ->select(['id', 'user_id', 'category_id'])
        ->with(['user:id,latitude,longitude', 'category' => function($q) {
            $q->select('id','name','is_active');
        }, 'category.fares' => function($q){ $q->where('is_active',1); }, 'category.faresDate' => function($q){ $q->where('is_active',1); }])
        ->whereIn('user_id', $availableDriverIds)
        ->where('is_primary', 1)
        ->whereHas('category', function ($q) {
            $q->where('is_active', 1)->whereHas('fares', fn($f) => $f->where('is_active',1));
        });

    if ($currentLatLng && isset($currentLatLng['lat']) && isset($currentLatLng['lng'])) {
        $lat = (float) $currentLatLng['lat'];
        $lng = (float) $currentLatLng['lng'];

        // Haversine - compute distance_km in SQL, filter by radius and order by it
        $haversine = "(6371 * acos( cos( radians(?) ) * cos( radians(user_latitude) ) * cos( radians(user_longitude) - radians(?) ) + sin( radians(?) ) * sin( radians(user_latitude) ) ) )";
        // But our user lat/lng are on user table via relationship. We'll join or select raw from users table fields.
        // Simpler: join users table to access lat/lng as columns named 'latitude' and 'longitude'
        $vehiclesQuery = Vehicle::join('users as u', 'u.id', '=', 'vehicles.user_id')
            ->whereIn('vehicles.user_id', $availableDriverIds)
            ->where('vehicles.is_primary', 1)
            ->whereHas('category', function ($q) {
                $q->where('is_active', 1)->whereHas('fares', fn($f) => $f->where('is_active',1));
            })
            ->selectRaw("vehicles.id, vehicles.user_id, vehicles.category_id, u.latitude AS user_latitude, u.longitude AS user_longitude, {$haversine} AS distance_km", [$lat, $lng, $lat])
            ->whereRaw("{$haversine} <= ?", [$lat, $lng, $lat, $searchRadiusKm]) // bounding radius filter
            ->orderBy('distance_km', 'asc')
            ->limit($maxCandidates);
    } else {
        // no current position => fallback: compute haversine from pickup if present (same approach) OR just limit by most-recent vehicles
        if ($pickup && isset($pickup['lat']) && isset($pickup['lng'])) {
            $lat = (float)$pickup['lat']; $lng = (float)$pickup['lng'];
            $haversine = "(6371 * acos( cos( radians(?) ) * cos( radians(u.latitude) ) * cos( radians(u.longitude) - radians(?) ) + sin( radians(?) ) * sin( radians(u.latitude) ) ) )";
            $vehiclesQuery = Vehicle::join('users as u', 'u.id', '=', 'vehicles.user_id')
                ->whereIn('vehicles.user_id', $availableDriverIds)
                ->where('vehicles.is_primary', 1)
                ->whereHas('category', function ($q) {
                    $q->where('is_active', 1)->whereHas('fares', fn($f) => $f->where('is_active',1));
                })
                ->selectRaw("vehicles.id, vehicles.user_id, vehicles.category_id, u.latitude AS user_latitude, u.longitude AS user_longitude, {$haversine} AS distance_km", [$lat, $lng, $lat])
                ->orderBy('distance_km','asc')
                ->limit($maxCandidates);
        } else {
            // last-resort: don't compute distances in DB; limit by updated_at (cheap)
            $vehiclesQuery = $vehiclesQuery->orderByDesc('vehicles.id')->limit($maxCandidates);
        }
    }

    $vehicles = $vehiclesQuery->get();

    // if we used join above, hydrates won't populate relations automatically â€” rehydrate necessary relations:
    $vehicleIds = $vehicles->pluck('id')->toArray();
    $vehicles = Vehicle::with(['user:id,latitude,longitude','category','category.fares','category.faresDate'])
                ->whereIn('id', $vehicleIds)
                ->get()
                // preserve db distance_km if available on the earlier result
                ->map(function($v) use ($vehicles){
                    $match = $vehicles->firstWhere('id', $v->id);
                    if ($match && isset($match->distance_km)) $v->distance_km = (float)$match->distance_km;
                    else $v->distance_km = INF;
                    return $v;
                });

    // 2) Now we have an ordered short-list. Call Google Distance Matrix only for top $matrixLimit
    if ($currentLatLng && $vehicles->count() > 0) {
        $top = $vehicles->sortBy('distance_km')->values()->take($matrixLimit);
        $topWithMatrix = $this->batchDistanceMatrixForVehicles($top, $currentLatLng);
        // replace updated top entries in vehicles list
        $topIds = $topWithMatrix->pluck('id')->toArray();
        $vehicles = $vehicles->map(function($v) use ($topWithMatrix, $topIds) {
            if (in_array($v->id, $topIds)) {
                $found = $topWithMatrix->firstWhere('id', $v->id);
                $v->distance_km = $found->distance_km;
                $v->distance_text = $found->distance_text ?? null;
                $v->duration_text = $found->duration_text ?? null;
            } else {
                // keep DB haversine as approximation
                $v->distance_text = $v->distance_text ?? null;
                $v->duration_text = $v->duration_text ?? null;
            }
            return $v;
        });
    } else {
        // No current coords -> rely on DB haversine or INF
    }

    // 3) compute trip distance/duration (use your existing calculateDistances wrapper)
    $trip = $this->calculateTripDistanceDuration($pickup, $drop); // returns ['distance'=>kmFloat,'duration'=>minFloat]

    // 4) For each category pick the nearest vehicle (by numeric distance_km) and compute fare (with caching)
    $currentDate = Carbon::now()->format('Y-m-d');
    $nearestVehicles = $vehicles->groupBy('category_id')->map(function($group) use ($trip, $currentDate) {
        $nearest = $group->sortBy('distance_km')->first();
        if (!$nearest || !$nearest->category) return null;

        $appliedFare = $this->getApplicableFareForVehicle($nearest, $currentDate);
        if ($appliedFare === null) return null;

        // Try caching computed fare for this combination (bucket distance to nearest 0.5 km)
        $distanceBucket = round(max(0, $trip['distance']) * 2) / 2.0; // e.g., 2.3 -> 2.5
        $cacheKey = "fare:cat:{$nearest->category_id}:dist:{$distanceBucket}:slot:{$appliedFare->id}:date:{$currentDate}";
        $totalFareBeforeGst = Cache::remember($cacheKey, now()->addMinutes(3), function() use ($appliedFare, $trip) {
            return $this->computeTotalFare($appliedFare, $trip['distance'], $trip['duration']);
        });

        $nearest->total_fare = round($this->applyGST($totalFareBeforeGst), 2);
        $nearest->trip = $trip;
        return $nearest;
    })->filter();

    return $nearestVehicles;
}

/**
 * Single batched call to Google Distance Matrix for a collection of vehicles.
 * Expects $vehicles to have ->user->latitude & ->user->longitude.
 * Returns vehicles collection with distance_km, distance_text, duration_text set.
 */
private function batchDistanceMatrixForVehicles($vehicles, array $originLatLng)
{
    $apiKey = env('GOOGLE_MAP_API_KEY');
    $mapIndexToVehicle = [];
    $destinations = [];

    foreach ($vehicles as $v) {
        if ($v->user && $v->user->latitude !== null && $v->user->longitude !== null) {
            $destinations[] = $v->user->latitude . ',' . $v->user->longitude;
            $mapIndexToVehicle[] = $v;
        } else {
            $v->distance_km = INF;
        }
    }

    if (empty($destinations) || !$apiKey) {
        // Use haversine for all if no API key
        foreach ($mapIndexToVehicle as $v) {
            $v->distance_km = $this->haversineDistance($originLatLng['lat'], $originLatLng['lng'], $v->user->latitude, $v->user->longitude);
            $v->distance_text = null; $v->duration_text = null;
        }
        return collect($mapIndexToVehicle);
    }

    $origin = $originLatLng['lat'] . ',' . $originLatLng['lng'];
    $destStr = implode('|', $destinations);
    $url = "https://maps.googleapis.com/maps/api/distancematrix/json?origins={$origin}&destinations={$destStr}&key={$apiKey}&mode=driving";

    try {
        $client = new Client(['timeout' => 5]);
        $res = $client->request('GET', $url);
        $data = json_decode($res->getBody(), true);

        if (isset($data['status']) && $data['status'] === 'OK') {
            $elements = $data['rows'][0]['elements'] ?? [];
            foreach ($elements as $idx => $el) {
                $v = $mapIndexToVehicle[$idx] ?? null;
                if (!$v) continue;
                if (isset($el['status']) && $el['status'] === 'OK') {
                    $v->distance_text = $el['distance']['text'] ?? null;
                    $v->duration_text = $el['duration']['text'] ?? null;
                    $v->distance_km = isset($el['distance']['value']) ? ($el['distance']['value'] / 1000.0) : $this->haversineDistance($originLatLng['lat'], $originLatLng['lng'], $v->user->latitude, $v->user->longitude);
                } else {
                    $v->distance_km = $this->haversineDistance($originLatLng['lat'], $originLatLng['lng'], $v->user->latitude, $v->user->longitude);
                    $v->distance_text = null; $v->duration_text = null;
                }
            }
        } else {
            // Google error -> fallback to haversine
            foreach ($mapIndexToVehicle as $v) {
                $v->distance_km = $this->haversineDistance($originLatLng['lat'], $originLatLng['lng'], $v->user->latitude, $v->user->longitude);
                $v->distance_text = null; $v->duration_text = null;
            }
        }
    } catch (\Exception $e) {
        // On exception fallback to haversine
        foreach ($mapIndexToVehicle as $v) {
            $v->distance_km = $this->haversineDistance($originLatLng['lat'], $originLatLng['lng'], $v->user->latitude, $v->user->longitude);
            $v->distance_text = null; $v->duration_text = null;
        }
    }

    return collect($mapIndexToVehicle);
}




















public function getFareByLocation(Request $request)
    {
        try {
            // Fetch online drivers
            $driversOnlineList = $this->userService->findUserByRole([
                'is_online' => true,
                'is_blocked' => false
            ], 'driver');

            // Extract driver IDs
            $driverIds = $driversOnlineList->pluck('id')->toArray();
            if (empty($driverIds)) {
                return $this->responseJson(false, 200, __('No Online Drivers Available'), []);
            }

            // Fetch drivers with ongoing bookings (status 1,2,3,4 and is_accept = 2)
            $busyDriverIds = Booking::whereIn('status', [1, 2, 3, 4])
                ->where('is_accepted', 2)
                ->pluck('driver_id')
                ->toArray();

            // Exclude busy drivers
            $availableDriverIds = array_diff($driverIds, $busyDriverIds);

            if (empty($availableDriverIds)) {
                return $this->responseJson(false, 200, __('No Available Drivers'), []);
            }

            // Fetch vehicles with active categories and fares
            $vehicles = Vehicle::with([
                'category.fares' => function ($query) {
                    $query->where('is_active', 1);
                },
                'user:id,latitude,longitude'
            ])
                ->whereIn('user_id', $availableDriverIds)
                ->where('is_primary', 1)
                ->whereHas('category', function ($query) {
                    $query->where('is_active', 1)->whereHas('fares', function ($fareQuery) {
                        $fareQuery->where('is_active', 1);
                    });
                })
                // ->select(['id', 'user_id', 'category_id'])
                ->orderByDesc('id')
                ->get();

            if ($vehicles->isEmpty()) {
                return $this->responseJson(false, 200, __('No Vehicles Available'), []);
            }

            // Calculate trip distance and duration
            $distances = calculateDistances($request->pickup, $request->drop);
            $totalDistanceKm = $distances['distance'] ?? 0;
            $totalDurationMin = round($distances['duration']) ?? 0;

            // Get current location if provided
            $currentLat = $request->input('lat');
            $currentLng = $request->input('lng');

            // Calculate distance from current location to each vehicle
            if ($currentLat && $currentLng) {
                foreach ($vehicles as $vehicle) {
                    if ($vehicle->user) {
                        $vehicle->distance = getFareLocCulateDistance($currentLat, $currentLng, $vehicle->user->latitude, $vehicle->user->longitude);
                    }
                }
            }

            $groupedVehicles = $vehicles->groupBy('category_id');
            $currentDate = Carbon::now()->format('Y-m-d');

            $nearestVehicles = $groupedVehicles->map(function ($vehicles) use ($totalDistanceKm, $totalDurationMin, $distances, $currentDate) {
                $nearestVehicle = $vehicles->sortBy('distance')->first();

                if (!$nearestVehicle || !$nearestVehicle->category) {
                    return null;
                }
                $appliedFare = null;
                // 1. Try special time slot fare (if any)
                $fareSpecial = getBaseFareFromSpecialTimeSlot($nearestVehicle->category->faresDate);
                if ($fareSpecial) {
                    // dd($nearestVehicle->category->faresDate);
                    if ($fareSpecial !== null) {
                        $appliedFare = $fareSpecial;
                        // dd($appliedFare);
                    }
                }
                // } else {
                // 2. Fallback to regular time slot fare
                // if ($appliedFare === null && $nearestVehicle->category->fares) {
                $fareRegular = getBaseFareFromTimeSlot($nearestVehicle->category->fares);
                if ($fareRegular !== null) {
                    $appliedFare = $fareRegular;
                }
                // }

                //  If no valid fare (or fare has null/invalid days), EXCLUDE this vehicle
                if ($appliedFare === null) {
                    return null;
                }

                // Calculate fare
                $totalFare = (float)($appliedFare->base_fare ?? 0)
                    + ((float)($appliedFare->rate_per_km ?? 0) * $totalDistanceKm)
                    + ((float)($appliedFare->rate_per_minute ?? 0) * $totalDurationMin);

                $nearestVehicle->total_fare = round(calculateAmountWithGST($totalFare), 2);
                $nearestVehicle->distance = $distances;

                return $nearestVehicle;
            })->filter(); // Removes null entries

            // dd($nearestVehicles->toArray());
            return $this->responseJson(true, 200, __('Vehicle Found Successfully'), VehicleNewResource::collection($nearestVehicles));
        } catch (\Exception $e) {
            logger()->error("Error: {$e->getMessage()} | File: {$e->getFile()} | Line: {$e->getLine()}");
            return $this->responseJson(false, 500, __('Something Went Wrong'));
        }
    }


if (!function_exists('getFareLocCulateDistance')) {
    function getFareLocCulateDistance($currentLat, $currentLng, $vehicleLatitude, $vehicleLongitude)
    {
        // dd($currentLat, $currentLng, $vehicleLatitude, $vehicleLongitude);
        $origins = $currentLat . ',' . $currentLng;
        $destinations = $vehicleLatitude . ',' . $vehicleLongitude;
        // Google API Key
        $apiKey = env('GOOGLE_MAP_API_KEY');
        $travelModes = ['driving', 'walking', 'bicycling', 'transit'];

        // Create the Google Distance Matrix API URL
        $url = "https://maps.googleapis.com/maps/api/distancematrix/json?origins={$origins}&destinations={$destinations}&key={$apiKey}";
        // Create a Guzzle client
        $client = new Client();
        // dd($url);
        // Make the request to the Google Distance Matrix API
        $response = $client->request('GET', $url);
        // Parse the JSON response
        $data = json_decode($response->getBody(), true);
        // dd($data);
        // Extract the distances and times
        $distance = [];
        $duration = [];
        if ($data['status'] === 'OK') {
            foreach ($data['rows'][0]['elements'] as $index => $element) {
                if ($element['status'] === 'OK') {
                    // dd($element['distance']['text']);
                    $distance = $element['distance']['text']; // e.g., "12.4 km"
                    $duration = $element['duration']['text']; // e.g., "18 mins"
                    "Distance to point " . ($index + 1) . ": $distance, Duration: $duration<br>";
                } else {
                    "Error for point " . ($index + 1) . ": " . $element['status'] . "<br>";
                }
            }
            return ['distance' => $distance, 'duration' => $duration];
            // dd($distance, $duration);
        } else {
            return "Error: " . $data['status'];
        }
        // }
    }
}
