
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;
use App\Models\Vehicle;
use App\Models\Booking;
use App\Http\Resources\VehicleNewResource;

public function getFareByLocation(Request $request)
{
    try {
        // Validate (you can change rules as you prefer)
        $request->validate([
            'pickup' => 'required|array',
            'drop'   => 'required|array',
            'lat'    => 'required|numeric',
            'lng'    => 'required|numeric',
        ]);

        $currentLat = (float) $request->input('lat');
        $currentLng = (float) $request->input('lng');
        $maxDistanceMeters = (int) config('site.search_radius_meters', 5000); // default 5000

        // 1) get online drivers
        $driversOnlineList = $this->userService->findUserByRole([
            'is_online' => true,
            'is_blocked' => false
        ], 'driver');

        $driverIds = $driversOnlineList->pluck('id')->toArray();
        if (empty($driverIds)) {
            return $this->responseJson(false, 200, __('No Online Drivers Available'), []);
        }

        // 2) exclude busy drivers
        $busyDriverIds = Booking::whereIn('status', [1,2,3,4])
            ->where('is_accepted', 2)
            ->pluck('driver_id')
            ->toArray();

        $availableDriverIds = array_values(array_diff($driverIds, $busyDriverIds));
        if (empty($availableDriverIds)) {
            return $this->responseJson(false, 200, __('No Available Drivers'), []);
        }

        // 3) compute trip distances (your existing helper)
        $distances = calculateDistances($request->input('pickup'), $request->input('drop'));
        $totalDistanceKm = (float) ($distances['distance'] ?? 0.0);
        $totalDurationMin = (int) round($distances['duration'] ?? 0);

        // 4) Try DB-level optimized query with window functions
        $nearestRows = collect();
        $dbDriver = DB::getDriverName(); // e.g., "mysql", "pgsql"
        $supportsWindow = $this->dbSupportsWindowFunctions();

        if ($supportsWindow) {
            // Haversine expression in meters (use RADIANS and functions available in MySQL)
            $haversine = "(
                6371000 * 2 * 
                ASIN(
                    SQRT(
                        POWER(SIN(RADIANS(u.latitude - :lat) / 2), 2) +
                        COS(RADIANS(:lat)) * COS(RADIANS(u.latitude)) *
                        POWER(SIN(RADIANS(u.longitude - :lng) / 2), 2)
                    )
                )
            )";

            // Build inner derived table with ROW_NUMBER() partitioned by category
            $bindings = ['lat' => $currentLat, 'lng' => $currentLng];

            $inner = DB::table('vehicles as v')
                ->join('users as u', 'v.user_id', '=', 'u.id')
                ->join('categories as c', 'v.category_id', '=', 'c.id')
                // restrict to available drivers + primary vehicle + active category
                ->whereIn('v.user_id', $availableDriverIds)
                ->where('v.is_primary', 1)
                ->where('c.is_active', 1)
                ->whereNotNull('u.latitude')
                ->whereNotNull('u.longitude')
                ->selectRaw("
                    v.id as vehicle_id,
                    v.user_id,
                    v.category_id,
                    u.latitude as driver_lat,
                    u.longitude as driver_lng,
                    {$haversine} as distance_m,
                    ROW_NUMBER() OVER (PARTITION BY v.category_id ORDER BY {$haversine}) as rn
                ", [$bindings['lat'], $bindings['lng'], $bindings['lat'], $bindings['lng'] /* repeated for second haversine */])
                ; // Note: bindings repeated; see note below

            // wrap in outer query so we can filter rn = 1 and distance <= maxDistanceMeters
            // Build raw SQL because Laravel's query builder doesn't let us easily reuse same expression twice with bindings and window functions
            $rawSql = "
                SELECT * FROM (
                    SELECT
                        v.id AS vehicle_id,
                        v.user_id,
                        v.category_id,
                        u.latitude AS driver_lat,
                        u.longitude AS driver_lng,
                        {$haversine} AS distance_m,
                        ROW_NUMBER() OVER (PARTITION BY v.category_id ORDER BY {$haversine}) AS rn
                    FROM vehicles v
                    JOIN users u ON v.user_id = u.id
                    JOIN categories c ON v.category_id = c.id
                    WHERE v.user_id IN (" . implode(',', array_map('intval', $availableDriverIds)) . ")
                      AND v.is_primary = 1
                      AND c.is_active = 1
                      AND u.latitude IS NOT NULL AND u.longitude IS NOT NULL
                ) t
                WHERE t.rn = 1
                  AND t.distance_m <= :maxDistance
            ";

            // Bindings: lat/lng used 2 times -> need four placeholders. We'll pass lat,lng,lat,lng then maxDistance
            $bindingsOrdered = [$currentLat, $currentLng, $currentLat, $currentLng, $maxDistanceMeters];

            $nearestRows = collect(DB::select($rawSql, $bindingsOrdered));
        }

        // 5) Fallback: bounding-box + PHP grouping (if DB not supporting window functions or zero results)
        if ($nearestRows->isEmpty()) {
            // bounding box around current lat/lng for maxDistanceMeters
            $earthRadius = 6371000; // meters
            $maxDist = $maxDistanceMeters;

            // approx degrees
            $deltaLat = rad2deg($maxDist / $earthRadius);
            $deltaLng = rad2deg($maxDist / ($earthRadius * cos(deg2rad($currentLat))));

            $minLat = $currentLat - $deltaLat;
            $maxLat = $currentLat + $deltaLat;
            $minLng = $currentLng - $deltaLng;
            $maxLng = $currentLng + $deltaLng;

            // fetch candidate vehicles limited by bounding box and DB filters (much smaller set)
            $candidates = DB::table('vehicles as v')
                ->join('users as u', 'v.user_id', '=', 'u.id')
                ->join('categories as c', 'v.category_id', '=', 'c.id')
                ->whereIn('v.user_id', $availableDriverIds)
                ->where('v.is_primary', 1)
                ->where('c.is_active', 1)
                ->whereBetween('u.latitude', [$minLat, $maxLat])
                ->whereBetween('u.longitude', [$minLng, $maxLng])
                ->select('v.id as vehicle_id', 'v.user_id', 'v.category_id', 'u.latitude as driver_lat', 'u.longitude as driver_lng')
                ->get();

            // compute accurate haversine and filter <= maxDist, group by category and pick nearest in PHP
            $haversine_php = function ($lat1, $lon1, $lat2, $lon2) {
                $lat1 = deg2rad($lat1);
                $lon1 = deg2rad($lon1);
                $lat2 = deg2rad($lat2);
                $lon2 = deg2rad($lon2);
                $dLat = $lat2 - $lat1;
                $dLon = $lon2 - $lon1;
                $a = sin($dLat/2) * sin($dLat/2) + cos($lat1) * cos($lat2) * sin($dLon/2) * sin($dLon/2);
                $c = 2 * atan2(sqrt($a), sqrt(1-$a));
                return 6371000 * $c;
            };

            $filtered = collect();
            foreach ($candidates as $c) {
                $dist = $haversine_php($currentLat, $currentLng, (float)$c->driver_lat, (float)$c->driver_lng);
                if ($dist <= $maxDist) {
                    $c->distance_m = (float) round($dist, 2);
                    $filtered->push($c);
                }
            }

            // group by category_id and pick minimum distance
            $nearestRows = $filtered->groupBy('category_id')->map(function ($rows) {
                return $rows->sortBy('distance_m')->first();
            })->values();
        }

        if ($nearestRows->isEmpty()) {
            return $this->responseJson(false, 200, __('No Vehicles Found Within :km km', ['km' => $maxDistanceMeters/1000]), []);
        }

        // 6) Load Vehicle models for selected vehicle_ids and eager-load relations needed for fare calculation
        $vehicleIds = $nearestRows->pluck('vehicle_id')->unique()->toArray();

        $vehicles = Vehicle::with([
            'category.fares' => fn($q) => $q->where('is_active', 1),
            'category.faresDate',
            'user:id,latitude,longitude'
        ])->whereIn('id', $vehicleIds)->get()->keyBy('id');

        // 7) Reconstruct nearestVehicles collection in same order and compute fares using your logic
        $resultVehicles = collect();
        foreach ($nearestRows as $row) {
            $vid = $row->vehicle_id;
            if (!isset($vehicles[$vid])) continue;

            $veh = $vehicles[$vid];
            // attach DB-computed distance (meters)
            $veh->distance_to_client = $row->distance_m ?? ($veh->user ? round($this->haversineMeters($currentLat,$currentLng,$veh->user->latitude,$veh->user->longitude),2) : null);

            // fare selection (special slot then regular)
            $appliedFare = null;
            if (!empty($veh->category->faresDate)) {
                $fs = getBaseFareFromSpecialTimeSlot($veh->category->faresDate);
                if ($fs !== null) $appliedFare = $fs;
            }
            if ($appliedFare === null && !empty($veh->category->fares)) {
                $fr = getBaseFareFromTimeSlot($veh->category->fares);
                if ($fr !== null) $appliedFare = $fr;
            }
            if ($appliedFare === null) continue; // skip category without fare

            $base = (float) ($appliedFare->base_fare ?? 0);
            $perKm = (float) ($appliedFare->rate_per_km ?? 0);
            $perMin = (float) ($appliedFare->rate_per_minute ?? 0);
            $rawFare = $base + ($perKm * $totalDistanceKm) + ($perMin * $totalDurationMin);
            $veh->total_fare = round(calculateAmountWithGST($rawFare), 2);
            $veh->trip_distance_km = $totalDistanceKm;
            $veh->trip_duration_min = $totalDurationMin;

            $resultVehicles->push($veh);
        }

        if ($resultVehicles->isEmpty()) {
            return $this->responseJson(false, 200, __('No Vehicle Match Found'), []);
        }

        // 8) Optionally sort categories by nearest distance or cheapest fare — currently by distance asc
        $resultVehicles = $resultVehicles->sortBy('distance_to_client')->values();

        return $this->responseJson(true, 200, __('Vehicle Found Successfully'), VehicleNewResource::collection($resultVehicles));
    } catch (\Illuminate\Validation\ValidationException $ve) {
        return $this->responseJson(false, 422, $ve->getMessage(), $ve->errors());
    } catch (\Exception $e) {
        logger()->error("getFareByLocation (advanced) Error: {$e->getMessage()} | {$e->getFile()} : {$e->getLine()}");
        return $this->responseJson(false, 500, __('Something Went Wrong'));
    }
}

/**
 * Return true if DB supports window functions (basic check).
 * Adjust if you want a more robust detection.
 */
private function dbSupportsWindowFunctions(): bool
{
    // MySQL 8+, MariaDB 10.3+, PostgreSQL all support window funcs
    $driver = DB::getDriverName();
    if ($driver === 'mysql') {
        $ver = DB::selectOne('select version() as v')->v;
        return version_compare(explode('-', $ver)[0], '8.0', '>=');
    }
    if ($driver === 'pgsql') return true;
    if ($driver === 'sqlite') {
        // SQLite 3.25+ supports window functions — quick check
        $ver = DB::selectOne('select sqlite_version() as v')->v;
        return version_compare($ver, '3.25.0', '>=');
    }
    // fallback: assume not supported
    return false;
}

/**
 * small helper used in fallback re-check (if needed)
 */
private function haversineMeters($lat1, $lng1, $lat2, $lng2)
{
    $lat1 = deg2rad($lat1); $lng1 = deg2rad($lng1);
    $lat2 = deg2rad($lat2); $lng2 = deg2rad($lng2);
    $dLat = $lat2 - $lat1; $dLng = $lng2 - $lng1;
    $a = sin($dLat/2) * sin($dLat/2) + cos($lat1) * cos($lat2) * sin($dLng/2) * sin($dLng/2);
    $c = 2 * atan2(sqrt($a), sqrt(1-$a));
    return 6371000 * $c;
}









public function getFareByLocation(Request $request)
   {
        try {
            // Fetch online drivers
            $driversOnlineList = $this->userService->findUserByRole([
                'is_online' => true,
                'is_blocked' => false
            ], 'driver');

            // Extract driver IDs
            $driverIds = $driversOnlineList->pluck('id')->toArray();
            if (empty($driverIds)) {
                return $this->responseJson(false, 200, __('No Online Drivers Available'), []);
            }

            // Fetch drivers with ongoing bookings (status 1,2,3,4 and is_accept = 2)
            $busyDriverIds = Booking::whereIn('status', [1, 2, 3, 4])
                ->where('is_accepted', 2)
                ->pluck('driver_id')
                ->toArray();

            // Exclude busy drivers
            $availableDriverIds = array_diff($driverIds, $busyDriverIds);

            if (empty($availableDriverIds)) {
                return $this->responseJson(false, 200, __('No Available Drivers'), []);
            }

            // Fetch vehicles with active categories and fares
            $vehicles = Vehicle::with([
                'category.fares' => function ($query) {
                    $query->where('is_active', 1);
                },
                'user:id,latitude,longitude'
            ])
                ->whereIn('user_id', $availableDriverIds)
                ->where('is_primary', 1)
                ->whereHas('category', function ($query) {
                    $query->where('is_active', 1)->whereHas('fares', function ($fareQuery) {
                        $fareQuery->where('is_active', 1);
                    });
                })
                // ->select(['id', 'user_id', 'category_id'])
                ->orderByDesc('id')
                ->get();

            if ($vehicles->isEmpty()) {
                return $this->responseJson(false, 200, __('No Vehicles Available'), []);
            }

            // Calculate trip distance and duration
            $distances = calculateDistances($request->pickup, $request->drop);
            $totalDistanceKm = $distances['distance'] ?? 0;
            $totalDurationMin = round($distances['duration']) ?? 0;

            // Get current location if provided
            $currentLat = $request->input('lat');
            $currentLng = $request->input('lng');

            // Calculate distance from current location to each vehicle
            if ($currentLat && $currentLng) {
                foreach ($vehicles as $vehicle) {
                    if ($vehicle->user) {
                        $vehicle->distance = getFareLocCulateDistance($currentLat, $currentLng, $vehicle->user->latitude, $vehicle->user->longitude);
                    }
                }
            }

            $groupedVehicles = $vehicles->groupBy('category_id');
            $currentDate = Carbon::now()->format('Y-m-d');

            $nearestVehicles = $groupedVehicles->map(function ($vehicles) use ($totalDistanceKm, $totalDurationMin, $distances, $currentDate) {
                $nearestVehicle = $vehicles->sortBy('distance')->first();

                if (!$nearestVehicle || !$nearestVehicle->category) {
                    return null;
                }
                $appliedFare = null;
                // 1. Try special time slot fare (if any)
                $fareSpecial = getBaseFareFromSpecialTimeSlot($nearestVehicle->category->faresDate);
                if ($fareSpecial) {
                    // dd($nearestVehicle->category->faresDate);
                    if ($fareSpecial !== null) {
                        $appliedFare = $fareSpecial;
                        // dd($appliedFare);
                    }
                }
                // } else {
                // 2. Fallback to regular time slot fare
                // if ($appliedFare === null && $nearestVehicle->category->fares) {
                $fareRegular = getBaseFareFromTimeSlot($nearestVehicle->category->fares);
                if ($fareRegular !== null) {
                    $appliedFare = $fareRegular;
                }
                // }

                //  If no valid fare (or fare has null/invalid days), EXCLUDE this vehicle
                if ($appliedFare === null) {
                    return null;
                }

                // Calculate fare
                $totalFare = (float)($appliedFare->base_fare ?? 0)
                    + ((float)($appliedFare->rate_per_km ?? 0) * $totalDistanceKm)
                    + ((float)($appliedFare->rate_per_minute ?? 0) * $totalDurationMin);

                $nearestVehicle->total_fare = round(calculateAmountWithGST($totalFare), 2);
                $nearestVehicle->distance = $distances;

                return $nearestVehicle;
            })->filter(); // Removes null entries

            // dd($nearestVehicles->toArray());
            return $this->responseJson(true, 200, __('Vehicle Found Successfully'), VehicleNewResource::collection($nearestVehicles));
        } catch (\Exception $e) {
            logger()->error("Error: {$e->getMessage()} | File: {$e->getFile()} | Line: {$e->getLine()}");
            return $this->responseJson(false, 500, __('Something Went Wrong'));
        }
    }
