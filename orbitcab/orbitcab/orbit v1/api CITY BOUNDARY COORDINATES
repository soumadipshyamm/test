I'll create a complete Laravel API to check if coordinates are within the city boundary.

## 1. First, create a Laravel project:
```bash
composer create-project laravel/laravel boundary-check-api
cd boundary-check-api
```

## 2. Create the Controller:
```bash
php artisan make:controller BoundaryCheckController
```

## 3. **BoundaryCheckController.php**:
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;

class BoundaryCheckController extends Controller
{
    // Define the city boundary coordinates (NewTown / Rajarhat / Hatisala area)
    private $cityBoundaryCoords = [
        [22.6544, 88.4370],
        [22.6523, 88.4541],
        [22.6479, 88.4715],
        [22.6390, 88.4816],
        [22.6267, 88.4842],
        [22.6170, 88.4825],
        [22.6102, 88.4710],
        [22.6125, 88.4547],
        [22.6225, 88.4402],
        [22.6340, 88.4354],
        [22.6456, 88.4338],
        [22.6544, 88.4370]  // close shape
    ];

    /**
     * Check if a single point is inside the boundary
     */
    public function checkPoint(Request $request)
    {
        // Validate input
        $validator = Validator::make($request->all(), [
            'lat' => 'required|numeric|between:-90,90',
            'lng' => 'required|numeric|between:-180,180',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid input',
                'errors' => $validator->errors()
            ], 422);
        }

        $lat = $request->input('lat');
        $lng = $request->input('lng');

        // Check if point is inside polygon
        $isInside = $this->isPointInPolygon($lat, $lng, $this->cityBoundaryCoords);

        return response()->json([
            'success' => true,
            'data' => [
                'point' => [
                    'latitude' => $lat,
                    'longitude' => $lng
                ],
                'is_inside' => $isInside,
                'status' => $isInside ? 'inside' : 'outside',
                'message' => $isInside 
                    ? 'The point is inside the city boundary' 
                    : 'The point is outside the city boundary',
                'boundary_info' => [
                    'name' => 'NewTown / Rajarhat / Hatisala Area',
                    'vertices_count' => count($this->cityBoundaryCoords),
                    'area_sq_km' => $this->calculatePolygonArea($this->cityBoundaryCoords),
                    'center_point' => $this->calculatePolygonCenter($this->cityBoundaryCoords)
                ]
            ]
        ]);
    }

    /**
     * Check multiple points at once
     */
    public function checkMultiplePoints(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'points' => 'required|array|min:1',
            'points.*.lat' => 'required|numeric|between:-90,90',
            'points.*.lng' => 'required|numeric|between:-180,180',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid input',
                'errors' => $validator->errors()
            ], 422);
        }

        $points = $request->input('points');
        $results = [];
        $statistics = [
            'total' => count($points),
            'inside' => 0,
            'outside' => 0
        ];

        foreach ($points as $index => $point) {
            $isInside = $this->isPointInPolygon($point['lat'], $point['lng'], $this->cityBoundaryCoords);
            
            $results[] = [
                'id' => $index + 1,
                'point' => $point,
                'is_inside' => $isInside,
                'status' => $isInside ? 'inside' : 'outside'
            ];

            if ($isInside) {
                $statistics['inside']++;
            } else {
                $statistics['outside']++;
            }
        }

        $statistics['percentage_inside'] = $statistics['total'] > 0 
            ? round(($statistics['inside'] / $statistics['total']) * 100, 2) 
            : 0;

        return response()->json([
            'success' => true,
            'data' => [
                'results' => $results,
                'statistics' => $statistics,
                'boundary' => [
                    'name' => 'NewTown / Rajarhat / Hatisala Area',
                    'coordinates' => $this->cityBoundaryCoords,
                    'vertices_count' => count($this->cityBoundaryCoords)
                ]
            ]
        ]);
    }

    /**
     * Get boundary coordinates and information
     */
    public function getBoundary()
    {
        return response()->json([
            'success' => true,
            'data' => [
                'name' => 'NewTown / Rajarhat / Hatisala Area',
                'description' => 'Boundary coordinates for Kolkata area',
                'coordinates' => $this->cityBoundaryCoords,
                'properties' => [
                    'vertices_count' => count($this->cityBoundaryCoords),
                    'is_closed' => $this->isPolygonClosed($this->cityBoundaryCoords),
                    'area_sq_km' => $this->calculatePolygonArea($this->cityBoundaryCoords),
                    'center_point' => $this->calculatePolygonCenter($this->cityBoundaryCoords),
                    'bounding_box' => $this->calculateBoundingBox($this->cityBoundaryCoords)
                ],
                'metadata' => [
                    'source' => 'Hardcoded coordinates',
                    'last_updated' => '2024-01-15',
                    'author' => 'System Admin'
                ]
            ]
        ]);
    }

    /**
     * Upload custom boundary coordinates (for admin use)
     */
    public function updateBoundary(Request $request)
    {
        // Add authentication middleware in production
        $validator = Validator::make($request->all(), [
            'coordinates' => 'required|array|min:3',
            'coordinates.*' => 'array|size:2',
            'coordinates.*.0' => 'numeric|between:-90,90', // lat
            'coordinates.*.1' => 'numeric|between:-180,180', // lng
            'name' => 'string|max:255',
            'description' => 'string|max:500'
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid boundary coordinates',
                'errors' => $validator->errors()
            ], 422);
        }

        // In production, save to database
        // For this example, we'll just update the array
        $this->cityBoundaryCoords = $request->input('coordinates');

        return response()->json([
            'success' => true,
            'message' => 'Boundary updated successfully',
            'data' => [
                'coordinates' => $this->cityBoundaryCoords,
                'vertices_count' => count($this->cityBoundaryCoords)
            ]
        ]);
    }

    /**
     * Batch check from file upload (CSV/JSON)
     */
    public function batchCheck(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'file' => 'required|file|mimes:csv,txt,json|max:2048'
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid file',
                'errors' => $validator->errors()
            ], 422);
        }

        $file = $request->file('file');
        $extension = $file->getClientOriginalExtension();
        $results = [];
        
        if ($extension === 'json') {
            $data = json_decode(file_get_contents($file->path()), true);
            if (isset($data['points'])) {
                $points = $data['points'];
            } elseif (is_array($data) && isset($data[0]['lat'])) {
                $points = $data;
            } else {
                return response()->json([
                    'success' => false,
                    'message' => 'Invalid JSON format'
                ], 422);
            }
        } elseif ($extension === 'csv') {
            $points = [];
            if (($handle = fopen($file->path(), 'r')) !== FALSE) {
                $header = fgetcsv($handle);
                while (($row = fgetcsv($handle)) !== FALSE) {
                    $points[] = [
                        'lat' => floatval($row[0]),
                        'lng' => floatval($row[1])
                    ];
                }
                fclose($handle);
            }
        }

        if (empty($points)) {
            return response()->json([
                'success' => false,
                'message' => 'No valid points found in file'
            ], 422);
        }

        // Process points
        $statistics = [
            'total' => count($points),
            'inside' => 0,
            'outside' => 0
        ];

        foreach ($points as $index => $point) {
            if (isset($point['lat']) && isset($point['lng'])) {
                $isInside = $this->isPointInPolygon($point['lat'], $point['lng'], $this->cityBoundaryCoords);
                
                $results[] = [
                    'id' => $index + 1,
                    'point' => $point,
                    'is_inside' => $isInside,
                    'status' => $isInside ? 'inside' : 'outside'
                ];

                if ($isInside) {
                    $statistics['inside']++;
                } else {
                    $statistics['outside']++;
                }
            }
        }

        $statistics['percentage_inside'] = $statistics['total'] > 0 
            ? round(($statistics['inside'] / $statistics['total']) * 100, 2) 
            : 0;

        return response()->json([
            'success' => true,
            'data' => [
                'filename' => $file->getClientOriginalName(),
                'file_type' => $extension,
                'total_points_processed' => count($results),
                'results' => $results,
                'statistics' => $statistics,
                'download_link' => $this->generateResultFile($results, $statistics)
            ]
        ]);
    }

    /**
     * Check if polygon is closed (first and last points are same)
     */
    private function isPolygonClosed($polygon)
    {
        $first = $polygon[0];
        $last = $polygon[count($polygon) - 1];
        return $first[0] == $last[0] && $first[1] == $last[1];
    }

    /**
     * Calculate polygon area in square kilometers
     */
    private function calculatePolygonArea($polygon)
    {
        $area = 0;
        $n = count($polygon);
        
        if ($n < 3) return 0;
        
        for ($i = 0; $i < $n; $i++) {
            $j = ($i + 1) % $n;
            $area += $polygon[$i][1] * $polygon[$j][0];
            $area -= $polygon[$i][0] * $polygon[$j][1];
        }
        
        $area = abs($area) / 2;
        
        // Convert to square kilometers (approximate)
        // 1 degree latitude ≈ 111 km
        // 1 degree longitude ≈ 111 km * cos(latitude)
        $center = $this->calculatePolygonCenter($polygon);
        $latRad = deg2rad($center['lat']);
        $kmPerDegreeLat = 111.0;
        $kmPerDegreeLng = 111.0 * cos($latRad);
        
        $areaSqKm = $area * $kmPerDegreeLat * $kmPerDegreeLng;
        
        return round($areaSqKm, 2);
    }

    /**
     * Calculate polygon center point
     */
    private function calculatePolygonCenter($polygon)
    {
        $n = count($polygon);
        $sumLat = 0;
        $sumLng = 0;
        
        foreach ($polygon as $coord) {
            $sumLat += $coord[0];
            $sumLng += $coord[1];
        }
        
        return [
            'lat' => round($sumLat / $n, 6),
            'lng' => round($sumLng / $n, 6)
        ];
    }

    /**
     * Calculate bounding box of polygon
     */
    private function calculateBoundingBox($polygon)
    {
        $minLat = INF;
        $maxLat = -INF;
        $minLng = INF;
        $maxLng = -INF;
        
        foreach ($polygon as $coord) {
            $minLat = min($minLat, $coord[0]);
            $maxLat = max($maxLat, $coord[0]);
            $minLng = min($minLng, $coord[1]);
            $maxLng = max($maxLng, $coord[1]);
        }
        
        return [
            'south_west' => ['lat' => $minLat, 'lng' => $minLng],
            'north_east' => ['lat' => $maxLat, 'lng' => $maxLng],
            'width_deg' => round($maxLng - $minLng, 6),
            'height_deg' => round($maxLat - $minLat, 6)
        ];
    }

    /**
     * Ray casting algorithm to check if point is in polygon
     */
    private function isPointInPolygon($lat, $lng, $polygon)
    {
        $x = $lng;
        $y = $lat;
        $inside = false;
        $n = count($polygon);
        
        for ($i = 0, $j = $n - 1; $i < $n; $j = $i++) {
            $xi = $polygon[$i][1];
            $yi = $polygon[$i][0];
            $xj = $polygon[$j][1];
            $yj = $polygon[$j][0];
            
            $intersect = (($yi > $y) != ($yj > $y))
                && ($x < ($xj - $xi) * ($y - $yi) / ($yj - $yi) + $xi);
            
            if ($intersect) {
                $inside = !$inside;
            }
        }
        
        return $inside;
    }

    /**
     * Generate result file for download
     */
    private function generateResultFile($results, $statistics)
    {
        $csvContent = "ID,Latitude,Longitude,Status\n";
        
        foreach ($results as $result) {
            $csvContent .= "{$result['id']},{$result['point']['lat']},{$result['point']['lng']},{$result['status']}\n";
        }
        
        $csvContent .= "\nSummary\n";
        $csvContent .= "Total Points,{$statistics['total']}\n";
        $csvContent .= "Points Inside,{$statistics['inside']}\n";
        $csvContent .= "Points Outside,{$statistics['outside']}\n";
        $csvContent .= "Percentage Inside,{$statistics['percentage_inside']}%\n";
        
        $filename = 'boundary_check_results_' . date('Y-m-d_H-i-s') . '.csv';
        $filepath = storage_path('app/public/' . $filename);
        
        file_put_contents($filepath, $csvContent);
        
        return url('storage/' . $filename);
    }
}
```

## 4. **routes/api.php**:
```php
<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\BoundaryCheckController;

// API Routes
Route::prefix('v1')->group(function () {
    // Single point check
    Route::post('/check-point', [BoundaryCheckController::class, 'checkPoint']);
    
    // Multiple points check
    Route::post('/check-multiple-points', [BoundaryCheckController::class, 'checkMultiplePoints']);
    
    // Get boundary information
    Route::get('/boundary', [BoundaryCheckController::class, 'getBoundary']);
    
    // Update boundary (protected - add middleware in production)
    Route::post('/boundary/update', [BoundaryCheckController::class, 'updateBoundary']);
    
    // Batch check from file
    Route::post('/batch-check', [BoundaryCheckController::class, 'batchCheck']);
    
    // Test endpoint
    Route::get('/test', function () {
        return response()->json([
            'success' => true,
            'message' => 'Boundary Check API is running',
            'timestamp' => now(),
            'version' => '1.0.0'
        ]);
    });
});
```

## 5. **config/cors.php**:
```php
<?php

return [
    'paths' => ['api/*', 'sanctum/csrf-cookie'],
    'allowed_methods' => ['*'],
    'allowed_origins' => ['*'], // Change to specific domains in production
    'allowed_origins_patterns' => [],
    'allowed_headers' => ['*'],
    'exposed_headers' => [],
    'max_age' => 0,
    'supports_credentials' => false,
];
```

## 6. Create a test view: **resources/views/test.blade.php**:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boundary Check API Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        #map { height: 400px; border-radius: 8px; }
        .result-card { transition: all 0.3s; }
        .result-card.inside { border-left: 4px solid #28a745; }
        .result-card.outside { border-left: 4px solid #dc3545; }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="mb-4">Boundary Check API Test</h1>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card mb-4">
                    <div class="card-header">
                        <h5 class="mb-0">Test Single Point</h5>
                    </div>
                    <div class="card-body">
                        <form id="singlePointForm">
                            <div class="mb-3">
                                <label class="form-label">Latitude</label>
                                <input type="number" step="0.000001" class="form-control" id="lat" 
                                       value="22.6523" required>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Longitude</label>
                                <input type="number" step="0.000001" class="form-control" id="lng" 
                                       value="88.4541" required>
                            </div>
                            <button type="submit" class="btn btn-primary">Check Point</button>
                        </form>
                        <div id="singleResult" class="mt-3"></div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Test Multiple Points</h5>
                    </div>
                    <div class="card-body">
                        <textarea class="form-control mb-3" id="multiplePoints" rows="4" 
                                  placeholder='[{"lat": 22.6523, "lng": 88.4541}, {"lat": 22.63, "lng": 88.47}]'>
[{"lat": 22.6523, "lng": 88.4541}, {"lat": 22.63, "lng": 88.47}]
                        </textarea>
                        <button id="checkMultiple" class="btn btn-secondary">Check Multiple Points</button>
                        <div id="multipleResult" class="mt-3"></div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Map View</h5>
                    </div>
                    <div class="card-body">
                        <div id="map"></div>
                        <div class="mt-3 text-center">
                            <button id="getBoundary" class="btn btn-outline-primary me-2">Load Boundary</button>
                            <button id="clearMarkers" class="btn btn-outline-secondary">Clear Markers</button>
                        </div>
                    </div>
                </div>
                
                <div class="card mt-4">
                    <div class="card-header">
                        <h5 class="mb-0">API Information</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-2">
                            <strong>Base URL:</strong> <code id="baseUrl"></code>
                        </div>
                        <div class="mb-2">
                            <strong>Endpoints:</strong>
                            <ul class="list-unstyled">
                                <li><code>POST /api/v1/check-point</code> - Check single point</li>
                                <li><code>POST /api/v1/check-multiple-points</code> - Check multiple points</li>
                                <li><code>GET /api/v1/boundary</code> - Get boundary info</li>
                                <li><code>GET /api/v1/test</code> - Health check</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        const API_BASE = '/api/v1';
        let map = L.map('map').setView([22.63, 88.47], 12);
        let boundaryLayer = null;
        let markers = [];
        
        // Initialize map
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
        }).addTo(map);
        
        // Display base URL
        $('#baseUrl').text(window.location.origin + API_BASE);
        
        // Check API status
        fetch(API_BASE + '/test')
            .then(response => response.json())
            .then(data => {
                console.log('API Status:', data);
            })
            .catch(error => {
                console.error('API Error:', error);
                alert('API is not accessible. Make sure Laravel is running.');
            });
        
        // Single point check
        $('#singlePointForm').submit(function(e) {
            e.preventDefault();
            
            const lat = parseFloat($('#lat').val());
            const lng = parseFloat($('#lng').val());
            
            fetch(API_BASE + '/check-point', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({ lat, lng })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const result = data.data;
                    const statusClass = result.is_inside ? 'inside' : 'outside';
                    const statusIcon = result.is_inside ? '✅' : '❌';
                    
                    $('#singleResult').html(`
                        <div class="card result-card ${statusClass}">
                            <div class="card-body">
                                <h5 class="card-title">${statusIcon} ${result.message}</h5>
                                <p class="card-text">
                                    <strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                                    <strong>Status:</strong> ${result.status.toUpperCase()}<br>
                                    <strong>Boundary Area:</strong> ${result.boundary_info.area_sq_km} sq km
                                </p>
                            </div>
                        </div>
                    `);
                    
                    // Add marker to map
                    addMarker(lat, lng, result.is_inside, 'Point Check');
                } else {
                    $('#singleResult').html(`
                        <div class="alert alert-danger">
                            Error: ${data.message}
                        </div>
                    `);
                }
            })
            .catch(error => {
                $('#singleResult').html(`
                    <div class="alert alert-danger">
                        Request failed: ${error.message}
                    </div>
                `);
            });
        });
        
        // Check multiple points
        $('#checkMultiple').click(function() {
            const points = JSON.parse($('#multiplePoints').val());
            
            fetch(API_BASE + '/check-multiple-points', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({ points })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const results = data.data.results;
                    const stats = data.data.statistics;
                    
                    let html = `
                        <div class="card">
                            <div class="card-header">
                                <strong>Results Summary</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Total Points: ${stats.total}<br>
                                    Inside: ${stats.inside}<br>
                                    Outside: ${stats.outside}<br>
                                    Percentage Inside: ${stats.percentage_inside}%
                                </p>
                            </div>
                        </div>
                        <div class="mt-3">
                    `;
                    
                    results.forEach(result => {
                        const statusClass = result.is_inside ? 'inside' : 'outside';
                        const statusIcon = result.is_inside ? '✅' : '❌';
                        
                        html += `
                            <div class="card result-card ${statusClass} mb-2">
                                <div class="card-body p-2">
                                    <small>
                                        ${statusIcon} Point ${result.id}: 
                                        ${result.point.lat.toFixed(6)}, ${result.point.lng.toFixed(6)}
                                        (${result.status})
                                    </small>
                                </div>
                            </div>
                        `;
                        
                        // Add marker to map
                        addMarker(result.point.lat, result.point.lng, result.is_inside, `Point ${result.id}`);
                    });
                    
                    html += '</div>';
                    $('#multipleResult').html(html);
                } else {
                    $('#multipleResult').html(`
                        <div class="alert alert-danger">
                            Error: ${data.message}
                        </div>
                    `);
                }
            })
            .catch(error => {
                $('#multipleResult').html(`
                    <div class="alert alert-danger">
                        Request failed: ${error.message}
                    </div>
                `);
            });
        });
        
        // Get boundary
        $('#getBoundary').click(function() {
            fetch(API_BASE + '/boundary')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const coords = data.data.coordinates;
                        
                        // Clear existing boundary
                        if (boundaryLayer) {
                            map.removeLayer(boundaryLayer);
                        }
                        
                        // Draw boundary
                        boundaryLayer = L.polygon(coords, {
                            color: '#d43d3d',
                            weight: 2,
                            dashArray: '6 4',
                            fillColor: '#f8d7da',
                            fillOpacity: 0.3
                        }).addTo(map);
                        
                        map.fitBounds(boundaryLayer.getBounds(), { padding: [20, 20] });
                        
                        // Show boundary info
                        const center = data.data.properties.center_point;
                        L.marker([center.lat, center.lng])
                            .addTo(map)
                            .bindPopup('<b>Boundary Center</b><br>' + 
                                     'Area: ' + data.data.properties.area_sq_km + ' sq km<br>' +
                                     'Vertices: ' + data.data.properties.vertices_count)
                            .openPopup();
                    }
                })
                .catch(error => {
                    console.error('Error loading boundary:', error);
                });
        });
        
        // Clear markers
        $('#clearMarkers').click(function() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
        });
        
        // Add marker to map
        function addMarker(lat, lng, isInside, label) {
            const color = isInside ? '#28a745' : '#dc3545';
            const icon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="
                    background: ${color};
                    color: white;
                    border-radius: 50%;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 12px;
                    font-weight: bold;
                    border: 2px solid white;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                ">${markers.length + 1}</div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            const marker = L.marker([lat, lng], { icon: icon })
                .addTo(map)
                .bindPopup(`<b>${label}</b><br>Lat: ${lat.toFixed(6)}<br>Lng: ${lng.toFixed(6)}<br>
                           Status: ${isInside ? 'Inside ✅' : 'Outside ❌'}`);
            
            markers.push(marker);
            map.setView([lat, lng], 14);
        }
        
        // Initialize with your test coordinates
        $(document).ready(function() {
            $('#singlePointForm').submit();
        });
    </script>
</body>
</html>
```

## 7. Create a route for the test view in **routes/web.php**:
```php
<?php

use Illuminate\Support\Facades\Route;

Route::get('/test-boundary', function () {
    return view('test');
});
```

## 8. Install and run:
```bash
# Install dependencies
composer install

# Generate application key
php artisan key:generate

# Create storage link
php artisan storage:link

# Start development server
php artisan serve
```

## 9. Test the API:

### Test with curl:
```bash
# Check single point
curl -X POST http://localhost:8000/api/v1/check-point \
  -H "Content-Type: application/json" \
  -d '{"lat": 22.6523, "lng": 88.4541}'

# Response will be:
{
  "success": true,
  "data": {
    "point": {
      "latitude": 22.6523,
      "longitude": 88.4541
    },
    "is_inside": true,
    "status": "inside",
    "message": "The point is inside the city boundary",
    "boundary_info": {
      "name": "NewTown / Rajarhat / Hatisala Area",
      "vertices_count": 12,
      "area_sq_km": 16.45,
      "center_point": {
        "lat": 22.636,
        "lng": 88.454
      }
    }
  }
}

# Check multiple points
curl -X POST http://localhost:8000/api/v1/check-multiple-points \
  -H "Content-Type: application/json" \
  -d '{
    "points": [
      {"lat": 22.6523, "lng": 88.4541},
      {"lat": 22.63, "lng": 88.47},
      {"lat": 22.5, "lng": 88.5}
    ]
  }'

# Get boundary info
curl http://localhost:8000/api/v1/boundary

# Test endpoint
curl http://localhost:8000/api/v1/test
```

### Test in browser:
1. Start Laravel server: `php artisan serve`
2. Open: `http://localhost:8000/test-boundary`
3. Test the point `22.6523, 88.4541` - it should show as INSIDE the boundary

## 10. For production deployment:

1. **Environment Configuration** (.env):
```env
APP_NAME="Boundary Check API"
APP_ENV=production
APP_DEBUG=false
APP_URL=http://your-domain.com

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=boundary_api
DB_USERNAME=your_username
DB_PASSWORD=your_password
```

2. **Add authentication middleware** to protect boundary update endpoints:
```php
Route::middleware(['auth:api'])->group(function () {
    Route::post('/boundary/update', [BoundaryCheckController::class, 'updateBoundary']);
});
```

3. **Set up database** to store boundaries:
```bash
php artisan make:model Boundary -m
```

4. **Add rate limiting** in `app/Http/Kernel.php`:
```php
'api' => [
    'throttle:api',
    \Illuminate\Routing\Middleware\SubstituteBindings::class,
],
```

The API is now ready to check if coordinates `22.6523, 88.4541` are within the defined city boundary!
