
export const completedCompetitionList = async (req: Request, res: Response): Promise<any> => {
	try {
		const userDetails = await getDetailsByEmail(req.user.email);
		const participant_object_id = userDetails?._id;
		const completedCompetitions = await CompetitionModel.find({
			status: "COMPLETED"
		}).populate("creator_company").populate("created_by").populate("competition_type").lean();

		return res.status(StatusCodes.OK).json({
			message: "Fetched upcoming competitions with metadata",
			Result: completedCompetitions,
		});
	} catch (error) {
		console.error('Error in ongoingCompetitionList:', error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: MESSAGE.get.fail,
			error: error instanceof Error ? error.message : 'Unknown error',
		});
	}
}
export const completedCompetitionRoundList = async (req: Request, res: Response): Promise<any> => {
	try {
		const { competitionId } = req.params;
		const roundList = await CompetitionModel.find({
			_id: competitionId
		}).lean();



		return res.status(StatusCodes.OK).json({
			message: "Fetched upcoming competitions with metadata",
			Result: roundList
		});
	} catch (error) {
		console.error('Error in ongoingCompetitionList:', error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: MESSAGE.get.fail,
			error: error instanceof Error ? error.message : 'Unknown error',
		});
	}
}
export const completedCompetitionRoundDetailsList = async (req: Request, res: Response): Promise<any> => {
	try {
		const { competitionId, roundId } = req.params;
		const roundParticipantList = await ParticipantModel.find({
			competition_object_id: competitionId,
			round_object_id: roundId
		}).populate('competition_object_id').populate('round_object_id').populate('participant_object_id').lean();
		return res.status(StatusCodes.OK).json({
			message: "Fetched upcoming competitions with metadata",
			Result: roundParticipantList
		});
	} catch (error) {
		console.error('Error in ongoingCompetitionList:', error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: MESSAGE.get.fail,
			error: error instanceof Error ? error.message : 'Unknown error',
		});
	}
}

export const myUpcomingCompetitionList = async (req: Request, res: Response): Promise<any> => {
	try {
		const currentDate = new Date();
		const userDetails = await getDetailsByEmail(req.user.email);
		//  Fetch upcoming competitions
		const fetchUpcomingCompetitions = await CompetitionModel.find({
			status: "ACTIVE",
			// challenge_start_date: { $gte: currentDate }
		})
			.populate("creator_company")
			.populate("created_by")
			.populate("competition_type")
			.lean();

		if (!fetchUpcomingCompetitions.length) {
			return res.status(StatusCodes.OK).json({
				message: "No upcoming competitions found.",
				Result: []
			});
		}
		//  Fetch participant details

		const participant_object_id = userDetails?._id;
		const competitionsWithMetadata = await Promise.all(
			fetchUpcomingCompetitions.map(async (competition) => {
				const current_round = await currentRoundss(competition._id.toString());
				if (!current_round || current_round.status !== 'upcoming') {
					console.warn(`No valid ongoing round for competition: ${competition._id} `);
					return null; // Skip if no valid ongoing round
				}

				// Get participant details for current round and user
				const participantDetails = await ParticipantModel.find({
					round_object_id: current_round?._id,
					participant_object_id,
					competition_object_id: competition?._id.toString()
				}).lean();

				// Check if participant has successfully enrolled
				const enrolled_competition = participantDetails.some(participant =>
					participant.participant_payment_status == "SUCCESS"
				);

				// Only return competition data if participant exists
				if (participantDetails.length > 0) {
					return {
						...competition,
						current_round,
						participantDetails,
						enrolled_competition
					};
				}
				return null;
			})
		);
		const validCompetitions = competitionsWithMetadata.filter(
			(comp): comp is NonNullable<typeof comp> => comp !== null
		);
		//  Final Response
		return res.status(StatusCodes.OK).json({
			message: "Fetched upcoming competitions with data",
			Result: validCompetitions,
		});
	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error: error,
		});
	}
}

export const myOngoingCompetitionList = async (
	req: Request,
	res: Response
): Promise<any> => {
	try {
		const currentDate = new Date();
		const userDetails = await getDetailsByEmail(req.user.email);

		if (!userDetails) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: "User details not found.",
				Result: [],
			});
		}

		// 🔹 Fetch ongoing competitions: currently active (start <= now <= end)
		const fetchOngoingCompetitions = await CompetitionModel.find({
			status: "ACTIVE",
			// challenge_start_date: { $lte: currentDate },
			// challenge_end_date: { $gte: currentDate },
		})
			.populate("creator_company")
			.populate("created_by")
			.populate("competition_type")
			.lean();

		if (!fetchOngoingCompetitions.length) {
			return res.status(StatusCodes.OK).json({
				message: "No ongoing competitions found.",
				Result: [],
			});
		}

		const participantObjectId = userDetails._id;
		const competitionsWithMetadata = await Promise.all(
			fetchOngoingCompetitions.map(async (competition) => {
				try {
					// Get current round (should be 'ongoing', not 'upcoming')
					const currentRound = await currentRoundss(competition._id.toString());

					// Only proceed if round exists AND is actually ongoing
					if (!currentRound || currentRound.status !== "ongoing") {
						console.debug(
							`Skipping competition ${competition._id}: no ongoing round (status: ${currentRound?.status})`
						);
						return null;
					}

					// Fetch participant details for this round and competition
					const participantDetails = await ParticipantModel.find({
						round_object_id: currentRound._id,
						participant_object_id: participantObjectId,
						competition_object_id: competition._id.toString(),
					}).lean();

					// Check if user has successfully paid/enrolled
					const enrolledCompetition = participantDetails.some(
						(p) => p.participant_payment_status === "SUCCESS"
					);

					// Only return data if the user is a participant
					if (participantDetails.length === 0) {
						return null;
					}

					return {
						...competition,
						current_round: currentRound,
						participantDetails,
						enrolled_competition: enrolledCompetition,
					};
				} catch (roundError) {
					console.error(
						`Error processing round for competition ${competition._id}:`,
						roundError
					);
					return null;
				}
			})
		);

		// Filter out nulls (non-ongoing or not enrolled)
		const validCompetitions = competitionsWithMetadata.filter(
			(comp): comp is NonNullable<typeof comp> => comp !== null
		);

		return res.status(StatusCodes.OK).json({
			message: "Fetched ongoing competitions with participant data.",
			Result: validCompetitions,
		});
	} catch (error) {
		console.error("Error in myOngoingCompetitionList:", error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error: error instanceof Error ? error.message : String(error),
		});
	}
};

export const myCompletedCompetitionList = async (
	req: Request,
	res: Response
): Promise<any> => {
	try {
		const currentDate = new Date();
		const userDetails = await getDetailsByEmail(req.user.email);

		if (!userDetails) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: "User details not found.",
				Result: [],
			});
		}

		const participantObjectId = userDetails._id;

		// 🔹 Fetch completed competitions: ended in the past
		const fetchCompletedCompetitions = await CompetitionModel.find({
			status: { $in: ["ACTIVE", "COMPLETED"] }, // could be marked completed or still active but ended
			// challenge_end_date: { $lt: currentDate }, // ended before now
		})
			.populate("creator_company")
			.populate("created_by")
			.populate("competition_type")
			.lean();

		if (!fetchCompletedCompetitions.length) {
			return res.status(StatusCodes.OK).json({
				message: "No completed competitions found.",
				Result: [],
			});
		}

		const competitionsWithMetadata = await Promise.all(
			fetchCompletedCompetitions.map(async (competition) => {
				try {
					// 🔄 Optionally: get the last/final round (could be useful)
					const finalRound = await currentRoundss(competition._id.toString());
					// Note: currentRoundss might return latest round regardless of status
					// If it doesn't support "last completed round", consider writing `getLastCompletedRound(competitionId)`

					// 🔍 Fetch all participant records for this user in this competition
					const participantDetails = await ParticipantModel.find({
						competition_object_id: competition._id.toString(),
						participant_object_id: participantObjectId,
					}).lean();

					// Filter to only successful enrollments
					const successfulEnrollments = participantDetails.filter(
						(p) => p.participant_payment_status === "SUCCESS"
					);

					// Skip if no successful enrollment
					if (successfulEnrollments.length === 0) {
						return null;
					}

					// ✅ Enrich with additional info
					return {
						...competition,
						final_round: finalRound || null, // may be null if no rounds exist
						participantDetails: successfulEnrollments,
						enrolled_competition: true,
						completion_status: "COMPLETED",
						// Optional: add ranking if available
						user_rank: (successfulEnrollments[0] as any).rank || null,
						final_score: (successfulEnrollments[0] as any)?.final_score || null,
					};
				} catch (err) {
					console.error(
						`Error processing completed competition ${competition._id}:`,
						err
					);
					return null; // skip on error
				}
			})
		);

		// Filter out nulls
		const validCompetitions = competitionsWithMetadata.filter(
			(comp): comp is NonNullable<typeof comp> => comp !== null
		);

		return res.status(StatusCodes.OK).json({
			message: "Fetched completed competitions with participant data.",
			Result: validCompetitions,
		});
	} catch (error) {
		console.error("Error in myCompletedCompetitionList:", error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error: error instanceof Error ? error.message : String(error),
		});
	}
};
