import { Request, Response } from "express";
import ParticipantModel from "../models/participant.model";
import VoteModel from "../models/vote.model";

export const getCompetitionParticipantsWithVotes = async (req: Request, res: Response) => {
  try {
    const { competitionId } = req.params;

    if (!competitionId) {
      return res.status(400).json({ message: "Competition ID is required" });
    }

    // Step 1: Find participants in this competition (status = participating)
    const participants = await ParticipantModel.aggregate([
      {
        $match: {
          competition_object_id: new mongoose.Types.ObjectId(competitionId),
          status: "participating",
        },
      },
      {
        // Step 2: Lookup votes for each participant
        $lookup: {
          from: "votes", // collection name in MongoDB
          localField: "_id", // participant _id
          foreignField: "participant_object_id", // vote participant ref
          as: "votes",
        },
      },
      {
        // Step 3: Count votes
        $addFields: {
          total_votes: { $size: "$votes" },
        },
      },
      {
        // Optional: project only necessary fields
        $project: {
          participant_name: 1,
          round_no: 1,
          competition_name: 1,
          total_votes: 1,
          "votes.voter_object_id": 1, // keep voter details if needed
        },
      },
    ]);

    return res.status(200).json({
      competitionId,
      participants,
    });
  } catch (error: any) {
    console.error("Error fetching participants with votes:", error);
    return res.status(500).json({ message: "Server error", error: error.message });
  }
};








export const participantVotedList = async (req: Request, res: Response): Promise<any> => {
  try {
    const userDetails = await getDetailsByEmail(req.user.email);

    if (!userDetails) {
      return res.status(StatusCodes.UNAUTHORIZED).json({
        message: "User not authenticated.",
      });
    }

    const { competitionId, roundId } = req.params;
    const voterId = userDetails._id;

    // Step 1: Get votes by this voter
    const voteFilter: any = { voter_object_id: voterId };
    if (competitionId) voteFilter.competition_object_id = competitionId;
    if (roundId) voteFilter.round_object_id = roundId;

    const votes = await VoteModel.find(voteFilter).lean();

    if (!votes || votes.length === 0) {
      return res.status(StatusCodes.NOT_FOUND).json({
        message: "No participants found (user has not voted).",
        data: [],
      });
    }

    // Step 2: Group participants by competition
    const competitionMap: Record<string, any> = {};

    for (const v of votes) {
      const compId = v.competition_object_id.toString();
      if (!competitionMap[compId]) {
        competitionMap[compId] = {
          competitionId: compId,
          competitionName: null, // will fill later
          participants: [],
        };
      }
      // Push participant if not already in list
      if (!competitionMap[compId].participants.some((p: any) => p.participantId === v.participant_object_id.toString())) {
        competitionMap[compId].participants.push({
          participantId: v.participant_object_id.toString(),
          name: null,
          email: null,
          profileImage: null,
          votesGiven: 0,
        });
      }
      // Increase vote count
      const p = competitionMap[compId].participants.find((p: any) => p.participantId === v.participant_object_id.toString());
      if (p) p.votesGiven += 1;
    }

    // Step 3: Fetch participant + competition details
    const participantIds = votes.map(v => v.participant_object_id.toString());
    const participants = await ParticipantModel.find({ _id: { $in: participantIds } })
      .populate({
        path: "competition_object_id",
        select: "name",
      })
      .populate({
        path: "user_object_id",
        select: "first_name last_name email profile_image",
      })
      .lean();

    // Fill details
    participants.forEach((p: any) => {
      const compId = p.competition_object_id?._id.toString();
      const compName = p.competition_object_id?.name;

      if (competitionMap[compId]) {
        competitionMap[compId].competitionName = compName;

        const participantEntry = competitionMap[compId].participants.find(
          (pp: any) => pp.participantId === p._id.toString()
        );
        if (participantEntry) {
          participantEntry.name = p.user_object_id
            ? `${p.user_object_id.first_name} ${p.user_object_id.last_name}`
            : "N/A";
          participantEntry.email = p.user_object_id?.email || null;
          participantEntry.profileImage = p.user_object_id?.profile_image || null;
        }
      }
    });

    // Step 4: Convert map to array
    const finalResult = Object.values(competitionMap);

    return res.status(StatusCodes.OK).json({
      message: MESSAGE.get.succ,
      data: finalResult,
    });

  } catch (error) {
    console.error(error);
    return res.status(StatusCodes.BAD_REQUEST).json({
      message: MESSAGE.get.fail,
      error,
    });
  }
};







export const getParticipantRoundStatuses = async (req: Request, res: Response): Promise<any> => {
	try {
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated.' });
		}

		const statusFilter = req.params.status as 'upcoming' | 'ongoing' | 'completed' | undefined;
		const now = dayjs();

		// Fetch active participations
		const participants = await ParticipantModel.find({
			participant_object_id: userDetails._id,
			status: { $in: ['PARTICIPATING'] }
		})
			.populate('competition_object_id', 'name challenge_start_date challenge_end_date competition_type no_of_rounds rounds')
			.populate('participant_object_id', 'name email avatar')
			.populate('transaction_object_id', 'amount status')
			.lean();

		if (!participants.length) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'No active participations found.',
			});
		}

		// Use map for grouping competitions
		const competitionMap: Record<string, any> = {};

		for (const p of participants) {
			const comp = p.competition_object_id as any;
			if (!comp || !Array.isArray(comp?.rounds)) continue;

			for (const round of comp.rounds) {
				const start = dayjs(round.start_date_time);
				const end = dayjs(round.end_date_time);

				let roundStatus: 'upcoming' | 'ongoing' | 'completed';
				if (start.isAfter(now)) {
					roundStatus = 'upcoming';
				} else if (start.isBefore(now) && end.isAfter(now)) {
					roundStatus = 'ongoing';
				} else {
					roundStatus = 'completed';
				}

				// Apply API param filter
				if (statusFilter && roundStatus !== statusFilter) continue;

				// If competition not yet added → initialize it
				if (!competitionMap[comp._id]) {
					competitionMap[comp._id] = {
						competition: {
							_id: comp._id,
							name: comp.name,
							challenge_start_date: comp.challenge_start_date,
							challenge_end_date: comp.challenge_end_date,
							competition_type: comp.competition_type,
							no_of_rounds: comp.no_of_rounds,
						},
						participant: {
							...p.participant_object_id,
							participantRoundStatus: p.status,
							participantRoundPaymentStatus: p.participant_payment_status,
						},
						rounds_list: [], // collect rounds here
					};
				}

				// Push round into this competition’s rounds_list
				competitionMap[comp._id].rounds_list.push({
					...round,
					status: roundStatus,
				});
			}
		}

		const result = Object.values(competitionMap);

		if (result.length === 0) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: `No rounds found for status: ${statusFilter || 'all'}.`,
			});
		}

		return res.status(StatusCodes.OK).json({
			message: 'Participant round status fetched successfully',
			result,
		});

	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: "An error occurred while fetching participant round statuses.",
			error: error instanceof Error ? error.message : error,
		});
	}
};








export const getParticipantRoundStatuses = async (req: Request, res: Response): Promise<any> => {
	try {
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated.' });
		}
		const statusFilter = req.params.status as 'upcoming' | 'ongoing' | 'completed';
		const now = dayjs();
		const participants = await ParticipantModel.find({
			participant_object_id: userDetails._id,
			status: { $in: ['PARTICIPATING'] }
		})
			.populate('competition_object_id')
			.populate('participant_object_id') // Limit participant fields
			.populate('transaction_object_id')
			.lean();

		console.log("participants-----------------------", participants);

		// const result = await Promise.all(participants.map(async (p: any, index: number) => {
		// 	const comp = p.competition_object_id;
		// 	if (!comp || !Array.isArray(comp.rounds)) return null;
		// 	const round = comp.rounds.find((r: any) => r.round_no === p.round_no);
		// 	if (!round) return null;
		// 	const roundStatus = get_round_status(round, now);
		// 	const time_status = getTimeStatus(round, now);

		// 	console.log("roundStatus-----------------------", roundStatus);

		// 	// Determine simplified round status
		// 	let status: 'upcoming' | 'ongoing' | 'completed' = 'completed';
		// 	if (dayjs(round.start_date_time).isAfter(now)) {
		// 		status = 'upcoming';
		// 	} else if (
		// 		dayjs(round.start_date_time).isBefore(now) &&
		// 		dayjs(round.end_date_time).isAfter(now)
		// 	) {
		// 		status = 'ongoing';
		// 	}

		// 	return {
		// 		current_rounds: [
		// 			{
		// 				...round,
		// 				roundStatus,
		// 				time_status: time_status,
		// 				status: status
		// 			}
		// 		],
		// 		competition: comp,
		// 		round_no: round.round_no,
		// 		participant: {
		// 			...p.participant_object_id,
		// 			participantRoundStatus: participants.length > 0 ? participants[0].status : null,
		// 			participantRoundPaymentStatus: participants.length > 0 ? participants[0].participant_payment_status : null
		// 		},
		// 	};
		// }));
		// console.log("result-----------------------", result);

		// Filter out nulls (where no round or comp was matched)
		// const filtered = result.filter(Boolean);
		// // Apply status filter if provided
		// let filteredResult = filtered;
		// // console.log("filtered-----------------------", filtered, statusFilter);

		// if (['upcoming', 'ongoing', 'completed'].includes(statusFilter)) {
		// 	// console.log("statusFilter-----------------------", statusFilter);

		// 	filteredResult = filtered.filter(r => r?.current_rounds[0]?.status == statusFilter);
		// 	// console.log("filteredResult-----------------------", filteredResult);
		// }

		// if (filteredResult.length === 0) {
		// 	return res.status(StatusCodes.NOT_FOUND).json({
		// 		message: 'No participant rounds found for the specified status.'
		// 	});
		// }


		if (!participants.length) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'No active participations found.',
			});
		}

		const result = [];

		// Process each participant and flatten rounds
		for (const p of participants) {
			const comp = p.competition_object_id as any;
			if (!comp || !Array.isArray(comp?.rounds)) continue;

			for (const round of comp?.rounds) {
				// Determine round status
				const start = dayjs(round.start_date_time);
				const end = dayjs(round.end_date_time);

				let roundStatus: 'upcoming' | 'ongoing' | 'completed';

				switch (true) {
					case start.isAfter(now):
						roundStatus = 'upcoming';
						break;
					case start.isBefore(now) && end.isAfter(now):
						roundStatus = 'ongoing';
						break;
					default:
						roundStatus = 'completed';
						break;
				}

				// Apply filter: only include if matches statusFilter
				if (statusFilter && ['upcoming', 'ongoing', 'completed'].includes(statusFilter)) {
					if (roundStatus !== statusFilter) {
						continue; // Skip if doesn't match
					}
				}

				// Push one entry per round
				result.push({
					current_rounds: [
						{
							...round,
							status: roundStatus, // Add simplified status
						},
					],
					competition: {
						_id: comp._id,
						name: comp.name,
						challenge_start_date: comp.challenge_start_date,
						challenge_end_date: comp.challenge_end_date,
						competition_type: comp.competition_type,
						no_of_rounds: comp.no_of_rounds,
					},
					round_no: round.round_no,
					participant: {
						...p.participant_object_id,
						participantRoundStatus: p.status,
						participantRoundPaymentStatus: p.participant_payment_status,
					},
				});
			}
		}

		// Final result
		if (result.length === 0) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: `No rounds found for status: ${statusFilter || 'all'}.`,
			});
		}

		return res.status(StatusCodes.OK).json({
			message: 'Participant round status fetched successfully',
			result: participants
		});

	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: "An error occurred during the payment process.",
			error: error
		});
	}
};







{
    "message": "Participant round status fetched successfully",
    "result": [
        {
            "_id": "68a5d162a8c4f8d0b0430153",
            "competition_object_id": {
                "_id": "689c2b975367f0ed84307c22",
                "name": "Test Competition",
                "challenge_start_date": "2025-08-25T00:00:00.000Z",
                "challenge_end_date": "2025-08-28T00:00:00.000Z",
                "competition_type": "685bf3baa025dd415af51cfe",
                "no_of_rounds": 3,
                "rounds": [
                    {
                        "round_no": 1,
                        "price": 160,
                        "start_date_time": "2025-08-13T14:56:00.000Z",
                        "end_date_time": "2025-08-14T11:45:00.000Z",
                        "additional_vote_package": "686564f9a3b58ebc3e9c18d9",
                        "checkpoints": "RCD1",
                        "free_voting_duration": 5,
                        "no_of_participant_proceeding": 33,
                        "status": "COMPLETED",
                        "_id": "689c2b975367f0ed84307c23"
                    },
                    {
                        "round_no": 2,
                        "price": 170,
                        "start_date_time": "2025-08-14T12:45:00.000Z",
                        "end_date_time": "2025-08-15T11:45:00.000Z",
                        "additional_vote_package": "6865651ba3b58ebc3e9c18e6",
                        "checkpoints": "RCD2",
                        "free_voting_duration": 8,
                        "no_of_participant_proceeding": 22,
                        "status": "COMPLETED",
                        "_id": "689c2b975367f0ed84307c24"
                    },
                    {
                        "round_no": 3,
                        "price": 180,
                        "start_date_time": "2025-08-27T11:00:00.000Z",
                        "end_date_time": "2025-08-28T11:30:00.000Z",
                        "additional_vote_package": "686564f9a3b58ebc3e9c18d9",
                        "checkpoints": "RCD3",
                        "free_voting_duration": 12,
                        "no_of_participant_proceeding": 48,
                        "status": "ONGOING",
                        "_id": "689c2b975367f0ed84307c25"
                    }
                ],
                "feature_image": "",
                "description": "Comp Desc",
                "round_checkpoint_start_visibility": true,
                "no_of_winner": 2,
                "prizes": [
                    {
                        "name": "P1",
                        "type": "gift",
                        "value": "Holiday Trip",
                        "money": null,
                        "gift": null,
                        "_id": "689c2b975367f0ed84307c26"
                    },
                    {
                        "name": "M1",
                        "type": "money",
                        "value": "20",
                        "money": null,
                        "gift": null,
                        "_id": "689c2b975367f0ed84307c27"
                    }
                ],
                "status": "ACTIVE",
                "file_type": [
                    "JPEG",
                    "PNG",
                    "MP4"
                ],
                "created_by": "689074cc19516f0a07d78252",
                "creator_company": "684ab7769fac4ec341fee3d2",
                "creator_description": "Competition Final Description",
                "remarks": "null",
                "createdAt": "2025-08-13T06:07:19.879Z",
                "updatedAt": "2025-08-26T18:42:20.030Z",
                "__v": 0
            },
            "participant_object_id": {
                "_id": "68765419c6ff9e5cb7072a94",
                "email": "participantss@test.com",
                "role": "PARTICIPANT",
                "__v": 0,
                "address_line_1": "kolkata",
                "address_line_2": "kolkata",
                "city": "kolkata",
                "contact_label": "HOME",
                "country": "I",
                "createdAt": "2025-07-15T13:14:01.560Z",
                "date": "2025-07-15T13:14:01.562Z",
                "date_of_birth": null,
                "devices_token": null,
                "expiresAt": "2025-07-15T13:19:01.554Z",
                "first_name": "Ben",
                "gender": "MALE",
                "is_approved": "APPROVED",
                "is_registered": true,
                "is_subscribe": false,
                "is_verified": true,
                "last_login_date": "2025-08-26T15:46:54.846Z",
                "last_name": "Lashley",
                "member_id": "P000002",
                "member_status": null,
                "middle_name": "",
                "otp": "7028",
                "password": "$2a$10$f435/rxszCcj1Ylzno0JRuzyyZCDpfYu4M8U1sKa.58AYBIMHg95u",
                "phone_extension": 91,
                "phone_number": 9012010799,
                "previous_role": null,
                "state": "WB",
                "updatedAt": "2025-08-26T15:46:54.851Z",
                "upload_back_side": [],
                "upload_front_side": [],
                "user_name": "superadmin",
                "zip": "700001",
                "discription": "aaaaaaaaaaaaaaaaaaaaaa"
            },
            "round_object_id": "689c2b975367f0ed84307c25",
            "competition_name": "Test Competition",
            "round_no": 1,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": "PENDING",
            "participant_payment_intant_id": "pi_3RyCK5BuHqQNZg722fm4X0VJ",
            "transaction_object_id": {
                "_id": "68a5d162a8c4f8d0b043014f",
                "payment_intent_id": "pi_3RyCK5BuHqQNZg722fm4X0VJ",
                "member_objectId": "68765419c6ff9e5cb7072a94",
                "competition_objectId": "689c2b975367f0ed84307c22",
                "type": "card",
                "payment_type": "card",
                "payment_status": "PENDING",
                "amount": 160,
                "transaction_status": "DEBITED",
                "transaction_date": "2025-08-20",
                "message": "COMPETITION PARTICIPATION",
                "payment_data": {
                    "id": "pi_3RyCK5BuHqQNZg722fm4X0VJ",
                    "object": "payment_intent",
                    "amount": 16000,
                    "amount_capturable": 0,
                    "amount_received": 0,
                    "application": null,
                    "application_fee_amount": null,
                    "automatic_payment_methods": {
                        "allow_redirects": "always",
                        "enabled": true
                    },
                    "canceled_at": null,
                    "cancellation_reason": null,
                    "capture_method": "automatic_async",
                    "client_secret": "pi_3RyCK5BuHqQNZg722fm4X0VJ_secret_VX5F3yN7VovHetttsUSnqYoDa",
                    "confirmation_method": "automatic",
                    "created": 1755697505,
                    "currency": "usd",
                    "customer": null,
                    "description": null,
                    "excluded_payment_method_types": null,
                    "invoice": null,
                    "last_payment_error": null,
                    "latest_charge": null,
                    "livemode": false,
                    "metadata": {
                        "memberId": "68765419c6ff9e5cb7072a94",
                        "type": "card"
                    },
                    "next_action": null,
                    "on_behalf_of": null,
                    "payment_method": null,
                    "payment_method_configuration_details": {
                        "id": "pmc_1OeI5vBuHqQNZg72lpqlJ4Vj",
                        "parent": null
                    },
                    "payment_method_options": {
                        "amazon_pay": {
                            "express_checkout_element_session_id": null
                        },
                        "card": {
                            "installments": null,
                            "mandate_options": null,
                            "network": null,
                            "request_three_d_secure": "automatic"
                        },
                        "link": {
                            "persistent_token": null
                        }
                    },
                    "payment_method_types": [
                        "card",
                        "link",
                        "cashapp",
                        "amazon_pay"
                    ],
                    "processing": null,
                    "receipt_email": null,
                    "review": null,
                    "setup_future_usage": null,
                    "shipping": null,
                    "source": null,
                    "statement_descriptor": null,
                    "statement_descriptor_suffix": null,
                    "status": "requires_payment_method",
                    "transfer_data": null,
                    "transfer_group": null
                },
                "respons_data": null,
                "createdAt": "2025-08-20T13:45:06.088Z",
                "updatedAt": "2025-08-20T13:45:06.088Z",
                "__v": 0
            },
            "content": {
                "description": "edsfghmn",
                "upload_date_time": "2025-08-21T14:54:07.470Z",
                "files": [
                    {
                        "url": "https://soumadipagol.s3.eu-north-1.amazonaws.com/competition/6717a5e433b37.png",
                        "name": "6717a5e433b37.png",
                        "_id": "68a7330f1ed96220cebe6dcd"
                    }
                ]
            },
            "thumbnail_url": {
                "files": [
                    {
                        "url": "https://soumadipagol.s3.eu-north-1.amazonaws.com/competition_thumbnail/6734a95103dde.png",
                        "name": "6734a95103dde.png",
                        "_id": "68a7330f1ed96220cebe6dce"
                    }
                ]
            },
            "status": "PARTICIPATING",
            "createdAt": "2025-08-20T13:45:06.108Z",
            "updatedAt": "2025-08-25T07:47:10.170Z",
            "__v": 0
        }
    ]
}



 "result": [
        {
            "_id": "68a5d162a8c4f8d0b0430153",
            "competition_object_id": "689c2b975367f0ed84307c22",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "689c2b975367f0ed84307c25",
            "competition_name": "Test Competition",
            "round_no": 1,
            "participant_name": "Ben Lashley",
            "participant_payment_type": null,
            "participant_payment_status": "PENDING",
            "participant_payment_intant_id": "pi_3RyCK5BuHqQNZg722fm4X0VJ",
            "transaction_object_id": "68a5d162a8c4f8d0b043014f",         
                        "status": "PARTICIPATING",
            "createdAt": "2025-08-20T13:45:06.108Z",
            "updatedAt": "2025-08-25T07:47:10.170Z",
            "__v": 0
        }
    ]


export const getParticipantRoundStatuses = async (req: Request, res: Response): Promise<any> => {
	try {
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated.' });
		}

		const statusFilter = req.params.status as 'upcoming' | 'ongoing' | 'completed' | undefined;
		const now = dayjs();

		// Fetch active participations
		const participants = await ParticipantModel.find({
			participant_object_id: userDetails._id,
			status: { $in: ['PARTICIPATING'] }
		})
			.populate('competition_object_id', 'name challenge_start_date challenge_end_date competition_type no_of_rounds rounds')
			.populate('participant_object_id', 'name email avatar')
			.populate('transaction_object_id', 'amount status')
			.lean();

		if (!participants.length) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'No active participations found.',
			});
		}

		const result: any[] = [];

		// Process each participant & filter by round status
		for (const p of participants) {
			const comp = p.competition_object_id as any;
			if (!comp || !Array.isArray(comp?.rounds)) continue;

			for (const round of comp.rounds) {
				const start = dayjs(round.start_date_time);
				const end = dayjs(round.end_date_time);

				let roundStatus: 'upcoming' | 'ongoing' | 'completed';
				if (start.isAfter(now)) {
					roundStatus = 'upcoming';
				} else if (start.isBefore(now) && end.isAfter(now)) {
					roundStatus = 'ongoing';
				} else {
					roundStatus = 'completed';
				}

				// Apply API param filter
				if (statusFilter && roundStatus !== statusFilter) continue;

				result.push({
					current_round: {
						...round,
						status: roundStatus,
					},
					competition: {
						_id: comp._id,
						name: comp.name,
						challenge_start_date: comp.challenge_start_date,
						challenge_end_date: comp.challenge_end_date,
						competition_type: comp.competition_type,
						no_of_rounds: comp.no_of_rounds,
					},
					round_no: round.round_no,
					participant: {
						...p.participant_object_id,
						participantRoundStatus: p.status,
						participantRoundPaymentStatus: p.participant_payment_status,
					},
				});
			}
		}

		if (result.length === 0) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: `No rounds found for status: ${statusFilter || 'all'}.`,
			});
		}

		return res.status(StatusCodes.OK).json({
			message: 'Participant round status fetched successfully',
			result,
		});

	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: "An error occurred while fetching participant round statuses.",
			error: error instanceof Error ? error.message : error,
		});
	}
};


