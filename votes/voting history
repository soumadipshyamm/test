
export const voteHistoryList = async (req: Request, res: Response): Promise<any> => {
	try {
		const userDetails = await getDetailsByEmail(req.user.email);

		const { competitionId, participantId, roundId } = req.params;

		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.'
			});
		}

		const voterId = userDetails?._id;

		// Build filter dynamically
		const filter: any = {
			voter_object_id: voterId,
		};

		if (competitionId) {
			filter.competition_object_id = competitionId;
		}

		if (participantId) {
			filter.participant_object_id = participantId;
		}
		if (roundId) {
			filter.round_object_id = roundId;
		}

		let fetchVotes = await VoteModel.find(filter)
			.populate({
				path: 'competition_object_id',
			})
			.populate({
				path: 'participant_object_id',
			})
			.sort({ createdAt: -1 })
			.lean();

		// ✅ Group by competition but keep array response
		const groupedVotes = Object.values(
			fetchVotes.reduce((acc: any, vote: any) => {
				const compId = vote.competition_object_id?._id?.toString();
				if (!acc[compId]) {
					acc[compId] = {
						competition_object_id: vote.competition_object_id,
						votes: [],
					};
				}
				acc[compId].votes.push(vote);
				return acc;
			}, {})
		);

		return res.status(StatusCodes.OK).json({
			message: MESSAGE.get.succ,
			data: groupedVotes, // still an array ✅
		});
	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error,
		});
	}
};


***************************





export const participantList = async (req: Request, res: Response): Promise<any> => {
  try {
    const userDetails = await getDetailsByEmail(req.user.email);

    if (!userDetails) {
      return res.status(StatusCodes.UNAUTHORIZED).json({
        message: "User not authenticated.",
      });
    }

    const { competitionId, roundId } = req.params;

    // Build filter dynamically
    const filter: any = {};
    if (competitionId) filter.competition_object_id = competitionId;
    if (roundId) filter.round_object_id = roundId;

    console.log("========= Participant Filter =========", filter);

    // Fetch multiple participants
    let participants = await ParticipantModel.find(filter)
      .populate({
        path: "competition_object_id",
        select: "name challenge_start_date challenge_end_date no_of_rounds",
      })
      .populate({
        path: "round_object_id",
        select: "round_number start_date end_date is_active",
      })
      .populate({
        path: "user_object_id", 
        select: "first_name last_name email profile_image",
      })
      .sort({ createdAt: -1 })
      .lean();

    if (!participants || participants.length === 0) {
      return res.status(StatusCodes.NOT_FOUND).json({
        message: "No participants found.",
        data: [],
      });
    }

    // Format all participants
    const formattedList = participants.map((p: any) => ({
      participantId: p._id,
      name: p.user_object_id 
        ? `${p.user_object_id.first_name} ${p.user_object_id.last_name}` 
        : "N/A",
      email: p.user_object_id?.email || null,
      profileImage: p.user_object_id?.profile_image || null,
      competition: {
        id: p.competition_object_id?._id,
        name: p.competition_object_id?.name,
        startDate: p.competition_object_id?.challenge_start_date,
        endDate: p.competition_object_id?.challenge_end_date,
        noOfRounds: p.competition_object_id?.no_of_rounds,
      },
      round: {
        id: p.round_object_id?._id,
        roundNumber: p.round_object_id?.round_number,
        startDate: p.round_object_id?.start_date,
        endDate: p.round_object_id?.end_date,
        isActive: p.round_object_id?.is_active,
      },
      createdAt: p.createdAt,
    }));

    return res.status(StatusCodes.OK).json({
      message: MESSAGE.get.succ,
      count: formattedList.length,
      data: formattedList,
    });

  } catch (error) {
    console.error(error);
    return res.status(StatusCodes.BAD_REQUEST).json({
      message: MESSAGE.get.fail,
      error,
    });
  }
};
***************************












export const voteHistoryRoundList = async (
	req: Request,
	res: Response
): Promise<any> => {
	try {
		// 1. Authenticate user
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.',
			});
		}

		const { competitionId, participantId } = req.params;

		// 2. Validate required params
		if (!competitionId || !participantId) {
			return res.status(StatusCodes.BAD_REQUEST).json({
				message: 'Competition ID and Participant ID are required.',
			});
		}

		const voterId = userDetails._id;

		// 3. Fetch votes
		const votes = await VoteModel.find({
			competition_object_id: competitionId,
			participant_object_id: participantId,
			voter_object_id: voterId,
		})
			.populate('competition_object_id') // competition
			.populate('participant_object_id') // participant
			.lean()
			.exec();

		if (!votes || votes.length === 0) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'No vote history found.',
			});
		}

		// 4. Fetch competition (for rounds)
		const competition = await CompetitionModel.findById(competitionId)
			.lean()
			.exec();

		if (!competition) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'Competition not found.',
			});
		}

		// 5. Map rounds
		const roundMap = new Map(
			competition.rounds.map((round: any) => [round._id.toString(), round])
		);

		// 6. Aggregate votes per round
		const roundVoteSummary: Record<
			string,
			{ freeVotes: number; paidVotes: number; totalVotes: number }
		> = {};

		votes.forEach(vote => {
			const roundId = vote.round_object_id?.toString();
			if (!roundId) return;

			if (!roundVoteSummary[roundId]) {
				roundVoteSummary[roundId] = {
					freeVotes: 0,
					paidVotes: 0,
					totalVotes: 0,
				};
			}

			roundVoteSummary[roundId].totalVotes += vote.vote_earned;

			if (vote.voting_type === 'FREE') {
				roundVoteSummary[roundId].freeVotes += vote.vote_earned;
			} else if (vote.voting_type === 'PAID') {
				roundVoteSummary[roundId].paidVotes += vote.vote_earned;
			}
		});

		// 7. Build round_details with votes
		const roundDetails = Object.keys(roundVoteSummary).map(roundId => {
			const round = roundMap.get(roundId);
			if (!round) return null;

			const summary = roundVoteSummary[roundId];
			return {
				_id: round._id,
				round_no: round.round_no,
				start_date_time: round.start_date_time,
				end_date_time: round.end_date_time,
				price: round.price,
				status: round.status,
				checkpoints: round.checkpoints,
				votes: {
					total: summary.totalVotes,
					free: summary.freeVotes,
					paid: summary.paidVotes,
				},
			};
		}).filter(Boolean);

		// 8. Final grouped response
		const result = {
			competition_object: votes[0].competition_object_id,
			participant_object: votes[0].participant_object_id,
			round_details: roundDetails,
		};

		return res.status(StatusCodes.OK).json({
			message: 'Vote history fetched successfully.',
			Result: result,
		});
	} catch (error) {
		console.error('Error in voteHistoryRoundList:', error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: 'Failed to fetch vote history.',
			error: error instanceof Error ? error.message : String(error),
		});
	}
};








export const voteHistoryRoundList = async (
	req: Request,
	res: Response
): Promise<any> => {
	try {
		// 1. Authenticate user
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.',
			});
		}

		const { competitionId, participantId } = req.params;

		// 2. Validate required params
		if (!competitionId || !participantId) {
			return res.status(StatusCodes.BAD_REQUEST).json({
				message: 'Competition ID and Participant ID are required.',
			});
		}

		const voterId = userDetails._id;

		// 3. Fetch votes
		const votes = await VoteModel.find({
			competition_object_id: competitionId,
			participant_object_id: participantId,
			voter_object_id: voterId,
		})
			.populate('competition_object_id') // full competition
			.populate('participant_object_id') // full participant
			.lean()
			.exec();

		if (!votes || votes.length === 0) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'No vote history found.',
			});
		}

		// 4. Fetch competition (for rounds)
		const competition = await CompetitionModel.findById(competitionId)
			.lean()
			.exec();

		if (!competition) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'Competition not found.',
			});
		}

		// 5. Map rounds
		const roundMap = new Map(
			competition.rounds.map((round: any) => [round._id.toString(), round])
		);

		// 6. Collect all unique round details where votes exist
		const roundDetails = votes
			.map(vote => roundMap.get(vote.round_object_id?.toString() || ''))
			.filter(Boolean); // remove nulls

		// 7. Final grouped response
		const result = {
			competition_object: votes[0].competition_object_id,
			participant_object: votes[0].participant_object_id,
			round_details: roundDetails,
		};

		return res.status(StatusCodes.OK).json({
			message: 'Vote history fetched successfully.',
			Result: result,
		});
	} catch (error) {
		console.error('Error in voteHistoryRoundList:', error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: 'Failed to fetch vote history.',
			error: error instanceof Error ? error.message : String(error),
		});
	}
};










export const voteHistoryRoundList = async (
	req: Request,
	res: Response
): Promise<any> => {
	try {
		// 1. Authenticate user
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.',
			});
		}

		const { competitionId, participantId } = req.params;

		// 2. Validate required params
		if (!competitionId || !participantId) {
			return res.status(StatusCodes.BAD_REQUEST).json({
				message: 'Competition ID and Participant ID are required.',
			});
		}

		const voterId = userDetails._id;

		// 3. Fetch vote history
		const votes = await VoteModel.find({
			competition_object_id: competitionId,
			participant_object_id: participantId,
			voter_object_id: voterId,
		})
			.populate('competition_object_id', 'name challenge_start_date challenge_end_date no_of_rounds rounds')
			.populate('participant_object_id', 'name email') // fetch details
			.lean()
			.exec();

		if (!votes || votes.length === 0) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'No vote history found.',
			});
		}

		// 4. Fetch competition with rounds
		const competition = await CompetitionModel.findById(competitionId)
			.select('name challenge_start_date challenge_end_date no_of_rounds rounds')
			.lean()
			.exec();

		if (!competition) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'Competition not found.',
			});
		}

		// 5. Build round map for quick lookup
		const roundMap = new Map(
			competition.rounds.map((round: any) => [round._id.toString(), round])
		);

		// 6. Merge round details into each vote
		const enrichedVotes = votes.map(vote => {
			const roundDetails = roundMap.get(vote.round_object_id?.toString() || '');
			return {
				...vote,
				round_details: roundDetails
					? {
							_id: roundDetails._id,
							round_no: roundDetails.round_no,
							start_date_time: roundDetails.start_date_time,
							end_date_time: roundDetails.end_date_time,
							price: roundDetails.price,
							status: roundDetails.status,
							checkpoints: roundDetails.checkpoints,
					  }
					: null,
			};
		});

		// 7. Final Result
		return res.status(StatusCodes.OK).json({
			message: 'Vote history fetched successfully.',
			Result: enrichedVotes,
		});
	} catch (error) {
		console.error('Error in voteHistoryRoundList:', error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: 'Failed to fetch vote history.',
			error: error instanceof Error ? error.message : String(error),
		});
	}
};











export const voteHistoryList = async (req: Request, res: Response): Promise<any> => {
	try {
		const userDetails = await getDetailsByEmail(req.user.email);

		const { competitionId, participantId, roundId } = req.params;

		const voterId = userDetails?._id;
		// Build filter dynamically
		const filter: any = {
			voter_object_id: voterId,
		};

		if (competitionId) {
			filter.competition_object_id = competitionId;
		}

		if (participantId) {
			filter.participant_object_id = participantId;
		}
		if (roundId) {
			filter.round_object_id = roundId;
		}


		console.log("===================================================", filter);

		// Note: `round_object_id` is likely NOT in Vote schema (see below)
		// So we can't directly filter by `roundId` unless it exists

		let fetchVotes = await VoteModel.find(filter)
			.populate({
				path: 'competition_object_id',
				// populate: { path: 'round_object_id' }
			})
			.populate({
				path: 'participant_object_id',
			})
			.sort({ createdAt: -1 })
			.lean();

		console.log("===================================================", fetchVotes);

		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.'
			});
		}

		return res.status(StatusCodes.OK).json({
			message: MESSAGE.get.succ,
			data: fetchVotes
		});
	} catch (error) {
		console.error(error);
		return res.status(StatusCodes.BAD_REQUEST).json({
			message: MESSAGE.get.fail,
			error
		});
	}
};

export const voteHistoryRoundList = async (
	req: Request,
	res: Response
): Promise<any> => {
	try {
		// 1. Authenticate user
		const userDetails = await getDetailsByEmail(req.user.email);
		if (!userDetails) {
			return res.status(StatusCodes.UNAUTHORIZED).json({
				message: 'User not authenticated.',
			});
		}

		const { competitionId, participantId } = req.params;

		// 2. Validate required params
		if (!competitionId || !participantId) {
			return res.status(StatusCodes.BAD_REQUEST).json({
				message: 'Competition ID and Participant ID are required.',
			});
		}

		const voterId = userDetails._id;

		// 3. Fetch vote history with populated data
		const votes = await VoteModel.find({
			competition_object_id: competitionId,
			participant_object_id: participantId,
			voter_object_id: voterId,
		})
			.populate('competition_object_id', 'name challenge_start_date challenge_end_date no_of_rounds rounds') // Optional: already fetched
			.populate('participant_object_id', 'participant_object_id') // Reference to User
			.lean()
			.exec();

		if (!votes || votes.length === 0) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'No vote history found.',
			});
		}

		// 4. Fetch competition
		const competition = await CompetitionModel.findById(competitionId)
			.select('name challenge_start_date challenge_end_date no_of_rounds rounds')
			.lean()
			.exec();

		if (!competition) {
			return res.status(StatusCodes.NOT_FOUND).json({
				message: 'Competition not found.',
			});
		}
		// 6. Get set of round IDs the user has voted in
		const votedRoundIds = new Set(
			votes
				.map(vote => vote.round_object_id?._id?.toString())
				.filter(Boolean) // Remove undefined
		);

		// 7. Filter and map only rounds where user has voted
		const roundList = competition.rounds
			.filter((round: any) => {
				return votedRoundIds.has(round._id.toString());
			})
			.map((round: any) => {
				return {
					_id: round._id,
					round_no: round.round_no,
					start_date_time: round.start_date_time,
					end_date_time: round.end_date_time,
					price: round.price,
					status: round.status, // Prefer DB status
					checkpoints: round.checkpoints,
				};
			});

		// 8. Build result object
		const result = {
			competition_details_object: competition,
			participant_details_object: votes[0].participant_object_id,
			round_list: roundList,
		};

		// 9. Return success response
		return res.status(StatusCodes.OK).json({
			message: 'Vote history fetched successfully.',
			Result: result, // Note: You used "Result" — keep consistent
		});
	} catch (error) {
		console.error('Error in voteHistoryRoundList:', error);
		return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
			message: 'Failed to fetch vote history.',
			error: error instanceof Error ? error.message : String(error),
		});
	}
};


"Result": [
        {
            "_id": "68a5bba050c7a0be971b5805",
            "competition_object_id": "689b25cf1368c12ffb0e7eef",
            "participant_object_id": "68765419c6ff9e5cb7072a94",
            "round_object_id": "689c2b975367f0ed84307c23",
            "voter_object_id": "68765419c6ff9e5cb7072a94",
            "vote_subscription_object_id": null,
            "vote_earned": 2,
            "voting_type": "PAID",
            "createdAt": "2025-08-20T12:12:16.695Z",
            "updatedAt": "2025-08-20T12:12:16.695Z",
            "__v": 0
        }
    ]








const competition = votes[0]?.competition_object_id;
votes.forEach(vote => {
  const round = competition?.rounds.id(vote.round_object_id);
  vote.round_details = round;
});
