– A scalable, web-based competition and voting platform developed with React and integrated with secure backend APIs. Enables users to register, join contests, submit entries, and participate in real-time voting with instant leaderboard updates.
Features Stripe payment gateway for secure transactions, Amazon S3 for cloud-based media storage, and SMTP integration for automated email notifications. Built with a responsive UI for seamless access across devices, and equipped with admin dashboards for contest management, payment tracking, and analytics

Contest Kingdom – A dynamic, web-based competition and voting platform built with React on the frontend and integrated with secure backend APIs. The system is designed to host and manage multiple contests, allowing participants to register, join competitions, and submit entries.
It includes real-time voting functionality, enabling users to vote for their favorite contestants and view instant live result updates. The platform supports responsive design for seamless use on desktop and mobile devices, with features like authentication, user dashboards, and administrative controls for managing contests, tracking votes, and generating analytics.







https://app.resumegiants.com/user/
import mongoose from "mongoose";

export const currentRound = async (competitionId: string, res: any): Promise<any> => {
    try {
        console.log("Fetching current round for competition ID:", competitionId);

        // ✅ Validate competitionId format
        if (!competitionId || !mongoose.Types.ObjectId.isValid(competitionId)) {
            return res.status(400).json({ message: "Invalid competition ID" });
        }

        const competition = await CompetitionModel.findById(competitionId).lean();

        // ✅ Ensure competition and rounds exist
        if (!competition) {
            return res.status(404).json({ message: "Competition not found" });
        }
        if (!Array.isArray(competition.rounds) || competition.rounds.length === 0) {
            return res.status(404).json({ message: "No rounds found for this competition" });
        }

        const now = new Date();

        // ✅ Filter only rounds with valid date fields
        const validRounds = competition.rounds.filter(r => {
            return r.start_date_time && r.end_date_time &&
                   !isNaN(new Date(r.start_date_time).getTime()) &&
                   !isNaN(new Date(r.end_date_time).getTime());
        });

        if (validRounds.length === 0) {
            return res.status(404).json({ message: "No valid rounds with proper dates" });
        }

        // ✅ Find ongoing round
        const ongoingRound = validRounds.find(r => {
            const start = new Date(r.start_date_time);
            const end = new Date(r.end_date_time);
            return start <= now && now <= end;
        });

        if (ongoingRound) {
            return res.json({
                status: "ongoing",
                time_status: "Ongoing now",
                ...roundResponse(ongoingRound)
            });
        }

        // ✅ Find nearest upcoming round
        const upcomingRounds = validRounds
            .filter(r => new Date(r.start_date_time) > now)
            .sort((a, b) => new Date(a.start_date_time).getTime() - new Date(b.start_date_time).getTime());

        if (upcomingRounds.length === 0) {
            // ✅ Optional: return completed status instead of 404
            return res.json({ status: "completed", message: "All rounds completed" });
        }

        const upcomingRound = upcomingRounds[0];
        const timeStatus = typeof calculateDuration === "function"
            ? calculateDuration(new Date(upcomingRound.start_date_time))
            : "Starting soon";

        return res.json({
            status: "upcoming",
            time_status: timeStatus,
            ...roundResponse(upcomingRound)
        });

    } catch (error) {
        console.error("Error determining current/upcoming round:", error);
        return res.status(500).json({ message: "Internal server error" });
    }
};

// ✅ Helper to avoid code repetition
const roundResponse = (round: any) => ({
    round_no: round?.round_no || null,
    price: round?.price || 0,
    start_date_time: round?.start_date_time || null,
    end_date_time: round?.end_date_time || null,
    free_voting_duration: round?.free_voting_duration || 0,
    no_of_participant_proceeding: round?.no_of_participant_proceeding || 0,
    additional_vote_package: round?.additional_vote_package || [],
    checkpoints: round?.checkpoints || [],
    _id: round?._id || null
});









export const currentRound = async (competitionId: string, res: any): Promise<any> => {
    try {
        console.log("Fetching current round for competition ID*******:", competitionId);

        const competition = await CompetitionModel.findById(competitionId);

        if (!competition || !competition.rounds || competition.rounds.length === 0) {
            return res.status(404).json({ message: "No rounds found" });
        }

        const now = new Date();

        // Try to find ongoing round
        const ongoingRound = competition.rounds.find(r => {
            const start = new Date(r.start_date_time);
            const end = new Date(r.end_date_time);
            return start <= now && now >= end;
        });

        if (ongoingRound) {
            return {
                status: "ongoing",
                time_status: "Ongoing now",
                round_no: ongoingRound.round_no,
                price: ongoingRound.price, // Assuming price is a field in the round object
                start_date_time: ongoingRound.start_date_time,
                end_date_time: ongoingRound.end_date_time,
                free_voting_duration: ongoingRound.free_voting_duration,
                no_of_participant_proceeding: ongoingRound.no_of_participant_proceeding,
                additional_vote_package: ongoingRound.additional_vote_package,
                checkpoints: ongoingRound.checkpoints,
                _id: ongoingRound._id

            };
        }

        // If no ongoing, find nearest upcoming
        const upcomingRounds = competition.rounds
            .filter(r => new Date(r.start_date_time) > now)
            .sort((a, b) => new Date(a.start_date_time).getTime() - new Date(b.start_date_time).getTime());

        if (upcomingRounds.length === 0) {
            return res.status(404).json({ message: "No upcoming rounds available" });
        }

        const upcomingRound = upcomingRounds[0];
        const timeStatus = calculateDuration(new Date(upcomingRound.start_date_time)); // Convert to Date

        return {
            status: "upcoming",
            time_status: timeStatus,
            round_no: upcomingRound.round_no,
            price: upcomingRound.price, // Assuming price is a field in the round object
            start_date_time: upcomingRound.start_date_time,
            end_date_time: upcomingRound.end_date_time,
            free_voting_duration: upcomingRound.free_voting_duration,
            no_of_participant_proceeding: upcomingRound.no_of_participant_proceeding,
            additional_vote_package: upcomingRound.additional_vote_package,
            checkpoints: upcomingRound.checkpoints,
            _id: upcomingRound._id
        };
    } catch (error) {
        console.error("Error determining current/upcoming round:", error);
        return res.status(500).json({ message: "Internal server error" });
    }
};
